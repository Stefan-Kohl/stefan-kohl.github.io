<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (GAP-Exercises) - Chapter 2: The Solutions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X85E0DEFD7F681250" name="X85E0DEFD7F681250"></a></p>
<div class="ChapSects"><a href="chap2.html#X85E0DEFD7F681250">2 <span class="Heading">The Solutions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7F07017C7CD62CFD">2.1 <span class="Heading">On Commutators and Derived Subgroups (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7CC64D5787EF16B2">2.2 <span class="Heading">On Outer Automorphisms Fixing Conjugacy Classes (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X84E2293F7956B8D0">2.3 <span class="Heading">Drawing the Ulam Spiral (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X867990408293E194">2.4 <span class="Heading">
  Automorphism Group of the Smallest Projective Plane (Solution)
</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X822F4BC78503EAA6">2.5 <span class="Heading">Installing a Missing Method (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7AD80CEF7E2B99F8">2.6 <span class="Heading">Finding Good abc Triples (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8783A105786126E6">2.7 <span class="Heading">Automorphism Groups of Finite Graphs (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7CF4B322817F814A">2.8 <span class="Heading">Enumerating Paths (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X80F2A2B17E44B79F">2.9 <span class="Heading">Wieferich Primes (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7E8385B57D503EB0">2.10 <span class="Heading">Counting Words in a File (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X868017AA79B0E23F">2.11 <span class="Heading">Non-Metabelian p-Groups (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7A6B2AE87EC8B582">2.12 <span class="Heading">The Growth of the Sum-of-Divisors Function (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7BBA21EA7C0FEA03">2.13 <span class="Heading">Pell's Equation (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X81ACCC777887640E">2.14 <span class="Heading">Automorphism Groups of Odd Order (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7F3E7A848496D8DD">2.15 <span class="Heading">Composite Sums (Solution)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X86BFAFD781969442">2.16 <span class="Heading">Rational Points on the Unit Sphere (Solution) </span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8719302881C72AB2">2.17 <span class="Heading">Aliquot Sequences (Solution) </span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7F9840A8797DA032">2.18 <span class="Heading">The Q Sequence (Solution) </span></a>
</span>
</div>
</div>

<h3>2 <span class="Heading">The Solutions</span></h3>

<p><a id="X7F07017C7CD62CFD" name="X7F07017C7CD62CFD"></a></p>

<h4>2.1 <span class="Heading">On Commutators and Derived Subgroups (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X83B2FD4187C233D7"><span class="RefLink">1.1</span></a>.</p>

<p>There is a function <code class="code">CommutatorLength(<var class="Arg">G</var>)</code>, which returns the minimal number <span class="SimpleMath">n</span> such that each element in the derived subgroup of the group <var class="Arg">G</var> can be written as a product of (at most) <span class="SimpleMath">n</span> commutators of elements of <var class="Arg">G</var>. For the groups we are looking for, this function returns a value greater than 1. However, <code class="code">CommutatorLength</code> is reasonably slow and we need to check many groups. Therefore we write an own little function as follows:</p>


<div class="example"><pre>

CommutatorsFormGroup := G -&gt; Length(Set(Cartesian(AsList(G),AsList(G)),
                                                  t -&gt; Comm(t[1],t[2])))
                           = Size(DerivedSubgroup(G));

</pre></div>

<p>Of course this function uses just a <em>brute-force</em> approach, and you might find it worth to look for a better algorithm to check whether the commutators form a subgroup -- but for our purposes it is sufficient as it stands. Now we simply need to loop over the groups stored in the Small Groups Library <a href="chapBib.html#biBSmallGroups">[BEO07]</a> until we find one for which this function returns <code class="code">false</code>:</p>


<div class="example"><pre>

gap&gt; n := 0;;
gap&gt; repeat
&gt;      n := n + 1; Print("n = ",n,"\n");
&gt;      G := First(AllGroups(n),G-&gt;not CommutatorsFormGroup(G));
&gt;    until G &lt;&gt; fail;

</pre></div>

<p>Certainly we could think about which groups we can already exclude by means of theory, but for our purposes here this turns out to be not necessary. We obtain the following:</p>


<div class="example"><pre>

gap&gt; IdGroup(G);
[ 96, 3 ]
gap&gt; StructureDescription(G);
"((C4 x C2) : C4) : C3"

</pre></div>

<p>The possible orders <span class="SimpleMath">≤ 256</span> of groups which have the desired property are 96, 128, 144, 162, 168, 192, 216, 240, 256. A low-degree permutation group with our property is</p>


<div class="example"><pre>

gap&gt; G := Group((1,3)(2,4),(5,7)(6,8),(9,11)(10,12),(13,15)(14,16),
&gt;               (1,3)(5,7)(9,11),(1,2)(3,4)(13,15),(5,6)(7,8)(13,14)(15,16),
&gt;               (9,10)(11,12));;
gap&gt; CommutatorLength(G);
2

</pre></div>

<p><a id="X7CC64D5787EF16B2" name="X7CC64D5787EF16B2"></a></p>

<h4>2.2 <span class="Heading">On Outer Automorphisms Fixing Conjugacy Classes (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X86A6B9EB848804CB"><span class="RefLink">1.2</span></a>.</p>

<p>We perform a <em>brute-force</em> search. For this we write straightforward code that uses a "problem-oriented" approach:</p>


<div class="example"><pre>

gap&gt; n := 1;;
gap&gt; repeat
&gt;      Print(n,"\n");
&gt;      G := First(AllGroups(n),
&gt;                 G -&gt; not IsAbelian(G)
&gt;                  and ForAny(AsList(AutomorphismGroup(G)),
&gt;                             aut -&gt; not IsInnerAutomorphism(aut)
&gt;                                and ForAll(AsList(G),
&gt;                                           g-&gt;IsConjugate(G,g,
&gt;                                                          Image(aut,g)))));
&gt;      n := n + 1;
&gt;    until G &lt;&gt; fail;

</pre></div>

<p>This loop runs a couple of minutes. This is likely less than the additional time it would take to exclude many groups from the search by means of theory or to write code which tests given groups faster. Nevertheless you might be interested in looking at this question from a theoretical point of view and in trying to find out more about the structure of groups which permit non-inner conjugacy class fixing automorphisms.</p>

<p>We obtain the following:</p>


<div class="example"><pre>

gap&gt; G;
&lt;pc group of size 32 with 5 generators&gt;
gap&gt; IdGroup(G);
[ 32, 43 ]

</pre></div>

<p>We would like to find a nice faithful permutation representation of <span class="SimpleMath">G</span> which permits us to see how our automorphism looks like. For this purpose we look for suitable subgroups, and let <span class="SimpleMath">G</span> act from the right on right cosets. Since <span class="SimpleMath">32 &gt; 4!</span>, there is no hope to find a faithful permutation representation of degree 4. However we can find one of degree 8:</p>


<div class="example"><pre>

gap&gt; S4 := Filtered(List(ConjugacyClassesSubgroups(G),Representative),
&gt;                   S-&gt;Size(S)=4);;
gap&gt; permreps := Set(Filtered(List(S4,S-&gt;Action(G,RightCosets(G,S),OnRight)),
&gt;                             H-&gt;Size(H)=32));
[ Group([ (1,2)(3,8)(4,6)(5,7), (2,8)(3,7)(5,6), (2,6)(5,8),
      (1,3,4,7)(2,5,6,8), (1,4)(2,6)(3,7)(5,8) ]) ]
gap&gt; G := permreps[1];;
gap&gt; ConjugacyClasses(G);
[ ()^G, (2,5)(3,7)(6,8)^G, (2,6)(5,8)^G, (2,8)(3,7)(5,6)^G, 
  (1,2)(3,8)(4,6)(5,7)^G, (1,2,3,5,4,6,7,8)^G, (1,2,4,6)(3,8,7,5)^G, 
  (1,2,7,8,4,6,3,5)^G, (1,3,4,7)(2,5,6,8)^G, (1,3,4,7)(2,8,6,5)^G, 
  (1,4)(2,6)(3,7)(5,8)^G ]
gap&gt; G := G^(4,5);; # we want (1,2,3,4,5,6,7,8) in G
gap&gt; List(ConjugacyClasses(G),Representative); # pick nicer generators ...
[ (), (2,4)(3,7)(6,8), (2,6)(4,8), (2,8)(3,7)(4,6), (1,2)(3,8)(4,7)(5,6),
  (1,2,3,4,5,6,7,8), (1,2,5,6)(3,8,7,4), (1,2,7,8,5,6,3,4),
  (1,3,5,7)(2,4,6,8), (1,3,5,7)(2,8,6,4), (1,5)(2,6)(3,7)(4,8) ]
gap&gt; G = Group((1,2,3,4,5,6,7,8),(2,4)(3,7)(6,8),(2,8)(3,7)(4,6));
true

</pre></div>

<p>Now let's have a look at our automorphism:</p>


<div class="example"><pre>

gap&gt; a := (1,2,3,4,5,6,7,8);; b := (2,4)(3,7)(6,8);; c := (2,8)(3,7)(4,6);;
gap&gt; G := Group(a,b,c);; # the nice representation determined above
gap&gt; A := AutomorphismGroup(G);
&lt;group of size 64 with 6 generators&gt;
gap&gt; auts := Filtered(AsList(A),
&gt;                     aut -&gt;  not IsInnerAutomorphism(aut)
&gt;                         and ForAll(AsList(G),
&gt;                                    g -&gt; IsConjugate(G,g,Image(aut,g))));;
gap&gt; Length(auts); # there are 16 suitable aut's -- find the nicest of them:
16
gap&gt; auts := Filtered(auts,aut-&gt;Image(aut,a)=a);; # those fixing a
gap&gt; Length(auts);
4
gap&gt; auts := Filtered(auts,aut-&gt;Image(aut,b)=b);; # those fixing b as well
gap&gt; Length(auts);
1
gap&gt; aut := auts[1];; # this one fixes a and b, and moves the generator c
gap&gt; c; Image(aut,c);
(2,8)(3,7)(4,6)
(1,5)(2,4)(6,8)
gap&gt; c/Image(aut,c);
(1,5)(2,6)(3,7)(4,8)
gap&gt; last = a^4; # our automorphism multiplies c by a^4
true
gap&gt; aut = GroupHomomorphismByImages(G,G,[a,b,c],[a,b,a^4*c]); # check
true

</pre></div>

<p><a id="X84E2293F7956B8D0" name="X84E2293F7956B8D0"></a></p>

<h4>2.3 <span class="Heading">Drawing the Ulam Spiral (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X8021163B7AA10C83"><span class="RefLink">1.3</span></a>.</p>

<p>We can write the function as follows:</p>


<div class="example"><pre>

UlamSpiral := function ( size, filename )

  local  spiral, smallprimes, n, p, r,
         middle, edgelength, edgepos, direction, i, j, zero, one;

  smallprimes := Filtered([2..size],IsPrimeInt);
  spiral      := NullMat(size,size,GF(2));

  if size mod 2 = 0 then middle := [size/2,size/2];
                    else middle := [(size + 1)/2,(size + 1)/2]; fi;

  zero := Zero(GF(2)); one := One(GF(2));

  spiral[middle[1]][middle[2]] := one;

  for p in smallprimes do
    i := middle[1]; j := middle[2];
    edgelength := 2; edgepos := 1; direction := 0; r := 1;
    for n in [2..size^2] do
      if   direction = 0 then j := j + 1;
      elif direction = 1 then i := i + 1;
      elif direction = 2 then j := j - 1;
      elif direction = 3 then i := i - 1; fi;
      r       := r + 1;
      edgepos := edgepos + 1;
      if r = p then
        if n &gt; p then spiral[i][j] := one; fi;
        r := 0;
      fi;
      if edgepos = edgelength then
        direction := (direction + 1) mod 4;
        if direction in [0,2] then edgelength := edgelength + 1; fi;
        edgepos := 1;
      fi;
    od;
  od;

  SaveAsBitmapPicture(spiral,filename);
end;

</pre></div>

<p>In this solution, we do a <em>Sieve of Eratosthenes</em> inside the spiral. This saves some memory, but doing the sieving before drawing the spiral would be faster.</p>

<p><a id="X867990408293E194" name="X867990408293E194"></a></p>

<h4>2.4 <span class="Heading">
  Automorphism Group of the Smallest Projective Plane (Solution)
</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X858A19237E85E12C"><span class="RefLink">1.4</span></a>.</p>

<p>We determine the requested automorphism group as a subgroup of the symmetric group of degree 7 as follows:</p>


<div class="example"><pre>

gap&gt; p7 := [[1,2,3],[1,4,7],[1,5,6],[2,4,6],[2,5,7],[3,4,5],[3,6,7]];;
gap&gt; G := SubgroupProperty(SymmetricGroup(7),x-&gt;Set(p7,g-&gt;Set(g,p-&gt;p^x))=p7);
Group([ (2,6)(3,5), (2,5)(3,6), (2,5,7)(3,6,4), (1,2,5,6,4,3,7) ])
gap&gt; StructureDescription(G);
"PSL(3,2)"

</pre></div>

<p>The group <span class="SimpleMath">G</span> is isomorphic to PSL(3,2) since the smallest projective plane is the one over the field GF(2) with 2 elements, and since the group PSL(<span class="SimpleMath">n</span>,<span class="SimpleMath">q</span>) is defined as the automorphism group of the projective space of affine dimension <span class="SimpleMath">n</span> (i.e. of projective dimension <span class="SimpleMath">n-1</span>) over GF(<span class="SimpleMath">q</span>). Our approach works since all groups we are dealing with are small, thus <code class="code">SubgroupProperty</code> is practical.</p>

<p><a id="X822F4BC78503EAA6" name="X822F4BC78503EAA6"></a></p>

<h4>2.5 <span class="Heading">Installing a Missing Method (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X7E8BCAC78695DB80"><span class="RefLink">1.5</span></a>.</p>

<p>We can implement the needed method as follows:</p>


<div class="example"><pre>

InstallMethod( Centre, "for simple groups", true, [ IsSimpleGroup ], 50,
               function( G )
                 if   IsAbelian( G ) then return G;
                 else return TrivialSubgroup( G ); fi;
               end );

</pre></div>

<p>We set the rank to 50 to make <strong class="pkg">GAP</strong>'s method selection choose this method in cases where multiple methods are applicable.</p>

<p><a id="X7AD80CEF7E2B99F8" name="X7AD80CEF7E2B99F8"></a></p>

<h4>2.6 <span class="Heading">Finding Good abc Triples (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X875EE5997CA845C5"><span class="RefLink">1.6</span></a>.</p>

<p>We can write the function as follows:</p>


<div class="example"><pre>

abcTriplesByRadical := function ( radical, bound )

  local  triples, values, values_last, factors, a, b, c, rad_abc, ratio;

  factors := Union(Factors(radical),[1]);
  values  := [1];
  repeat
    values_last := values;
    values := Filtered(Union(List(factors,p-&gt;values*p)),n-&gt;n&lt;bound);
  until values = values_last;
  triples := [];
  for a in values do
    for b in values do
      if b &gt;= a then break; fi;
      if a + b in values and Gcd(a,b) = 1 then
        c       := a + b;
        rad_abc := Product(Set(Factors(a*b*c)));
        ratio   := LOG_FLOAT(Float(c))/LOG_FLOAT(Float(rad_abc));
        if ratio &gt; 7/5 then Add(triples,[a,b,c]); fi;
      fi;
    od;
  od;
  return triples;
end;

</pre></div>

<p>In the first loop we determine all positive integers less than <var class="Arg">bound</var> all of whose prime factors divide <var class="Arg">radical</var>. For this we neither perform a loop over all integers in the range from 1 to <var class="Arg">bound</var> nor we factor integers. In the nested loop afterwards we determine the abc triples by a <em>brute-force</em> search.</p>

<p>We obtain for example the following:</p>


<div class="example"><pre>

gap&gt; abcTriplesByRadical( 2 * 3 * 5 * 7, 10000 );
[ [ 125, 3, 128 ], [ 2400, 1, 2401 ], [ 4374, 1, 4375 ] ]
gap&gt; abcTriplesByRadical( 2 * 3 * 23 * 109, 10^7 );
[ [ 6436341, 2, 6436343 ] ]

</pre></div>

<p>The latter is currently the best known abc triple. Its ratio is <span class="SimpleMath">ln(c)/ln( rad(abc)) ≈ 1.62991</span>.</p>

<p>A more elaborate method to search for good abc triples is described in <a href="chapBib.html#biBDokchitser03">[Dok03]</a>.</p>

<p><a id="X8783A105786126E6" name="X8783A105786126E6"></a></p>

<h4>2.7 <span class="Heading">Automorphism Groups of Finite Graphs (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X84042AFF837539CC"><span class="RefLink">1.7</span></a>.</p>


<dl>
<dt><strong class="Mark">ad a)</strong></dt>
<dd><p>We let the symmetric group of the set of vertices act on the set of all graphs with the given number of vertices. The orbits under that action are the isomorphism classes. As said in the hints, we obtain the set of all graphs with <var class="Arg">n</var> vertices by <code class="code">Combinations(Combinations([1..<var class="Arg">n</var>],2))</code>. We can write a <strong class="pkg">GAP</strong> function which takes an argument <var class="Arg">n</var> and which returns a set of representatives for the isomorphism classes of graphs with <var class="Arg">n</var> vertices:</p>


<div class="example"><pre>

AllGraphs := n -&gt; List(Orbits(SymmetricGroup(n),
                              Combinations(Combinations([1..n],2)),
                              function(Gamma,g)
                                return Set(Gamma,k-&gt;OnSets(k,g));
                              end),
                       Representative);

</pre></div>

<p>For <var class="Arg">n</var> = 1, 2, 3, 4, 5 and 6, we obtain 1, 2, 4, 11, 34 and 156 graphs, respectively. We observe a significant increase in runtime requirements between <var class="Arg">n</var> = 5 and <var class="Arg">n</var> = 6.</p>

</dd>
<dt><strong class="Mark">ad b)</strong></dt>
<dd><p>We can write the <strong class="pkg">GAP</strong> function as follows:</p>


<div class="example"><pre>

GraphAutomorphismGroup := function( Gamma, n )
  return SubgroupProperty(SymmetricGroup(n),
                          g -&gt; Set(Gamma,k-&gt;OnSets(k,g)) = Set(Gamma));
end;

</pre></div>

<p>Of course we could put much more effort into writing such a function in order to obtain a satisfactory performance also for reasonably large graphs -- but for our purposes the given one is already good enough.</p>

</dd>
<dt><strong class="Mark">ad c)</strong></dt>
<dd><p>We write a <strong class="pkg">GAP</strong> function which determines all transitive permutation groups of given degree <var class="Arg">n</var> which occur as automorphism groups of graphs:</p>


<div class="example"><pre>

TransitiveGraphAutomorphismGroups := function( n )

  local  graphs, groups; 

  graphs := AllGraphs(n);
  groups := Filtered(List(graphs,Gamma-&gt;GraphAutomorphismGroup(Gamma,n)),
                     G -&gt; IsTransitive(G,[1..n]));
  return AllTransitiveGroups(NrMovedPoints,n)
           {Set(groups,TransitiveIdentification)};
end;

</pre></div>

<p>As often, it is possible to abridge this function without performance loss:</p>


<div class="example"><pre>

TransitiveGraphAutomorphismGroups :=
  n -&gt; AllTransitiveGroups(NrMovedPoints,n)
         {Set(Filtered(List(AllGraphs(n),
                            Gamma-&gt;GraphAutomorphismGroup(Gamma,n)),
                       G -&gt; IsTransitive(G,[1..n])),
              TransitiveIdentification)};

</pre></div>

<p>In general one needs to be a bit careful to avoid computing the same things again and again, to avoid filling up the memory with junk objects and to recognize other possible sources of performance problems when one shrinks functions in such a way.</p>

<p>We obtain the following:</p>


<div class="example"><pre>

gap&gt; TransitiveGraphAutomorphismGroups(3);
[ S3 ]
gap&gt; TransitiveGraphAutomorphismGroups(4);
[ D(4), S4 ]
gap&gt; TransitiveGraphAutomorphismGroups(5);
[ D(5) = 5:2, S5 ]
gap&gt; TransitiveGraphAutomorphismGroups(6);
[ D(6) = S(3)[x]2, 2S_4(6) = [2^3]S(3) = 2 wr S(3), 
  F_36(6):2 = [S(3)^2]2 = S(3) wr 2, S6 ]
gap&gt; List(last, Size);
[ 12, 48, 72, 720 ]
gap&gt; List(last2, GeneratorsOfGroup);
[ [ (1,2,3,4,5,6), (1,4)(2,3)(5,6) ], [ (3,6), (1,3,5)(2,4,6), (1,5)(2,4) ], 
  [ (2,4,6), (2,4), (1,4)(2,5)(3,6) ], [ (1,2,3,4,5,6), (1,2) ] ]
gap&gt; List(last3, StructureDescription);
[ "D12", "C2 x S4", "(S3 x S3) : C2", "S6" ]

</pre></div>

<p>Now we determine the corresponding graphs. Since the automorphism group of a graph is invariant under taking the complement, we can restrict our considerations to graphs with at most <span class="SimpleMath">[frac12 ⋅ binom62] = 7</span> edges -- complements of solutions are then solutions as well.</p>


<div class="example"><pre>

gap&gt; HomogeneousGraphs :=
&gt;      Filtered(AllGraphs(6),
&gt;               Gamma -&gt; Length(Gamma) &lt;= 7 and
&gt;                        IsTransitive(GraphAutomorphismGroup(Gamma,6),
&gt;                                     [1..6]));
[ [  ], [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 4, 5 ], [ 4, 6 ], [ 5, 6 ] ], 
  [ [ 1, 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], [ 5, 6 ] ], 
  [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ] ]
gap&gt; List(HomogeneousGraphs, Gamma -&gt; Size(GraphAutomorphismGroup(Gamma, 6)));
[ 720, 72, 12, 48 ]

</pre></div>

<p>Thus for the dihedral group of order 12 we get the hexagon, for <span class="SimpleMath">C_2 ≀ S_3</span> we get the graph consisting of 3 disconnected edges, for <span class="SimpleMath">S_3 ≀ C_2</span> we get the graph consisting of 2 separate triangles, and for <span class="SimpleMath">S_6</span> we get the empty graph.</p>

</dd>
</dl>
<p>There is a <strong class="pkg">GAP</strong> package GRAPE <a href="chapBib.html#biBGRAPE">[Soi02]</a>, which is dedicated to computations with graphs.</p>

<p><a id="X7CF4B322817F814A" name="X7CF4B322817F814A"></a></p>

<h4>2.8 <span class="Heading">Enumerating Paths (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X7CCCEDEF79312B71"><span class="RefLink">1.8</span></a>.</p>


<dl>
<dt><strong class="Mark">ad a)</strong></dt>
<dd><p>We can write the following function to determine a suitable <span class="SimpleMath">x ∈ Z^24 × 24</span>:</p>


<div class="example"><pre>

TranspositionMatrixSn := function ( n )

  local  x, Sn, transpositions, line, g, t;

  Sn := AsList(SymmetricGroup(n));
  transpositions := List(Combinations([1..n],2),t-&gt;(t[1],t[2]));
  x := [];
  for g in Sn do
    line := ListWithIdenticalEntries(Factorial(n), 0);
    for t in transpositions do line[Position(Sn,g*t)] := 1; od;
    Add(x, line);
  od;
  return x;
end;

</pre></div>

<p>The lines and columns of the matrix correspond to the elements <span class="SimpleMath">1 = g_1, dots, g_24</span> of <span class="SimpleMath">S_4</span>, and it is</p>

<p><span class="SimpleMath">x_ij = 1</span> if there is a transposition <span class="SimpleMath">t</span> such that <span class="SimpleMath">g_i t = g_j</span>, and <span class="SimpleMath">x_ij = 0</span> otherwise. It is easy to check that <span class="SimpleMath">(x^n)_ij</span> is the number of ways to take <span class="SimpleMath">g_i</span> to <span class="SimpleMath">g_j</span> by multiplication from the right by <span class="SimpleMath">n</span> transpositions. Therefore we get the solution as follows:</p>


<div class="example"><pre>

gap&gt; x := TranspositionMatrixSn(4);; y := x^100;; y[1][1];
54443218625005908841390855596504818378095309207030310578760502581913955860480

</pre></div>

</dd>
<dt><strong class="Mark">ad b)</strong></dt>
<dd><p>We can write the following function to determine a suitable <span class="SimpleMath">x ∈ Z^64 × 64</span>:</p>


<div class="example"><pre>

HorsesMatrix := function ( )

  local  x, board, moves, m, i, j;

  x := [];
  for i in [1..8] do
    for j in [1..8] do
      board := NullMat(8,8);
      moves := [[i-2,j-1], [i-2,j+1], [i-1,j-2], [i-1,j+2],
                [i+2,j+1], [i+2,j-1], [i+1,j+2], [i+1,j-2]];
      for m in Intersection(moves,Cartesian([1..8],[1..8]))
      do board[m[1]][m[2]] := 1; od;
      Add(x,Flat(board));
    od;
  od;
  return x;
end;

</pre></div>

<p>We proceed analogous to Part a). Here the lines and columns of the correspond to the 64 squares of the chess board, and the matrix is filled with zeros and ones in such a way that <span class="SimpleMath">x_ij = 1</span> if and only if the horse can jump from square <span class="SimpleMath">i</span> to square <span class="SimpleMath">j</span> in one move. Similar as above, we get the solution as follows:</p>


<div class="example"><pre>

gap&gt; x := HorsesMatrix();;
gap&gt; y := x^100;; y[1][64];
2593244602149234588139078903115618952040745476069710377506002611030781169300

</pre></div>

</dd>
</dl>
<p><a id="X80F2A2B17E44B79F" name="X80F2A2B17E44B79F"></a></p>

<h4>2.9 <span class="Heading">Wieferich Primes (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X81B0B3817B0A915E"><span class="RefLink">1.9</span></a>.</p>

<p>We can write the function as follows:</p>


<div class="example"><pre>

IsWieferichPrimeInt := p -&gt; IsPrimeInt(p) and PowerModInt(2,p-1,p^2) = 1;

</pre></div>

<p>The first two Wieferich primes can be found very quickly:</p>


<div class="example"><pre>

gap&gt; Filtered([1..10000],IsWieferichPrimeInt);
[ 1093, 3511 ]

</pre></div>

<p>However, presently no third Wieferich prime is known. In case there is one, it must be greater than <span class="SimpleMath">1.25 ⋅ 10^15</span> (cf. <span class="URL"><a href=" http://www.loria.fr/~zimmerma/records/Wieferich.status">McIntosh 2004</a></span>).</p>

<p>Assuming "equidistribution" of the residues <span class="SimpleMath">(2^p-1-1)/p</span> mod <span class="SimpleMath">p</span>, one might argue that the "probability" of a prime <span class="SimpleMath">p</span> to be a Wieferich prime should be about <span class="SimpleMath">1/p</span>. Since the series <span class="SimpleMath">∑_p prime} 1/p</span> diverges, this would suggest that there are infinitely many Wieferich primes. More concisely, one would expect that there are roughly <span class="SimpleMath">ln(ln(n))</span> Wieferich primes less than a given bound <span class="SimpleMath">n</span>. Following these speculations, the expected number of Wieferich primes below the current bound of <span class="SimpleMath">1.25 ⋅ 10^15</span> would be <span class="SimpleMath">3.548</span>, while the actual number is 2. Obviously no reasonable statistical conclusions can be made from that difference.</p>

<p>Well -- when trying random primes, it seems that you might perhaps have a little chance of finding a new Wieferich prime!</p>

<p><a id="X7E8385B57D503EB0" name="X7E8385B57D503EB0"></a></p>

<h4>2.10 <span class="Heading">Counting Words in a File (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X7EA102507FD3E28D"><span class="RefLink">1.10</span></a>.</p>

<p>We can write the function as follows:</p>


<div class="example"><pre>

WordCount := filename -&gt; Collected(WordsString(StringFile(filename)));

</pre></div>

<p><a id="X868017AA79B0E23F" name="X868017AA79B0E23F"></a></p>

<h4>2.11 <span class="Heading">Non-Metabelian p-Groups (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X8184A6AF7A47566C"><span class="RefLink">1.11</span></a>.</p>

<p>Let <span class="SimpleMath">p</span> be a prime. It is well-known that groups of order <span class="SimpleMath">p</span> or <span class="SimpleMath">p^2</span> are always abelian, and that groups of prime-power order are solvable. Therefore a non-metabelian <span class="SimpleMath">p</span>-group must at least have order <span class="SimpleMath">p^6</span>. Further it is easy to see that a group is metabelian if and only if its derived subgroup is abelian. Thus we can proceed as follows:</p>


<div class="example"><pre>

gap&gt; G := First( AllGroups( 64), G -&gt; not IsAbelian( DerivedSubgroup(G) ) );
fail
gap&gt; G := First( AllGroups(128), G -&gt; not IsAbelian( DerivedSubgroup(G) ) );
&lt;pc group of size 128 with 7 generators&gt;
gap&gt; IdGroup(G);
[ 128, 134 ]
gap&gt; StructureDescription(G);
"((C4 : C8) : C2) : C2"
gap&gt; StructureDescription( DerivedSubgroup(G) );
"C2 x D8"

</pre></div>

<p>There is a complete classification of the positive integers <span class="SimpleMath">n</span> such that all groups of order <span class="SimpleMath">n</span> are metabelian. See <a href="chapBib.html#biBPazderski80">[Paz80]</a>.</p>

<p><a id="X7A6B2AE87EC8B582" name="X7A6B2AE87EC8B582"></a></p>

<h4>2.12 <span class="Heading">The Growth of the Sum-of-Divisors Function (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X7DC7587782057E18"><span class="RefLink">1.12</span></a>.</p>

<p>We can compute floating point approximations for <span class="SimpleMath">H(n)</span> and <span class="SimpleMath">B(n)</span> in <strong class="pkg">GAP</strong> as follows:</p>


<div class="example"><pre>

H := n -&gt; Sum([1..n],i-&gt;Float(1/i));
B := n -&gt; H(n) + LOG_FLOAT(H(n)) * EXP_FLOAT(H(n));

</pre></div>

<p>We obtain for example</p>


<div class="example"><pre>

gap&gt; List( [ 1 .. 60 ], n -&gt; B(n) - Sigma(n) );
[ 0, 0.317169, 1.62453, 0.977983, 4.38227, 0.834179, 7.32927, 2.86332, 
  7.43259, 5.03387, 13.6644, 0.321837, 17.0041, 9.70942, 12.4362, 8.1831, 
  23.9489, 5.73238, 27.5327, 8.34888, 21.1802, 20.0258, 34.8851, 1.7575, 
  33.6424, 25.5393, 30.4477, 17.3671, 46.2972, 7.2375, 50.1877, 22.1475, 
  40.1165, 37.0945, 46.0811, 6.0761, 62.0793, 43.0903, 50.1091, 19.1353, 
  70.1688, 19.2093, 74.2568, 37.311, 46.3717, 55.4389, 82.5122, 9.59174, 
  79.6772, 46.7685, 70.8655, 47.9681, 95.0762, 32.1896, 83.3082, 38.432, 
  81.5609, 74.6946, 107.833, 2.97668 ]

</pre></div>

<p>However we cannot answer the question whether there is a positive integer <span class="SimpleMath">n</span> such that <span class="SimpleMath">σ(n) &gt; B(n)</span> -- in fact, Jeffrey C. Lagarias <a href="chapBib.html#biBLagarias02">[Lag02]</a> has shown that this question is equivalent to the <span class="URL"><a href=" http://en.wikipedia.org/wiki/Riemann_Hypothesis">Riemann hypothesis</a></span>!</p>

<p><a id="X7BBA21EA7C0FEA03" name="X7BBA21EA7C0FEA03"></a></p>

<h4>2.13 <span class="Heading">Pell's Equation (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X846DB3D77F820871"><span class="RefLink">1.13</span></a>.</p>

<p>We can write the function as follows:</p>


<div class="example"><pre>

FundamentalSolutionOfPellsEquation := function ( n )

  local  x, periodlength, approx;

  if n = RootInt(n,2)^2 then return fail; fi;
  x := Indeterminate(Integers);
  periodlength := Length(ContinuedFractionExpansionOfRoot(x^2-n,0)) - 1;
  if   periodlength mod 2 = 0
  then approx := ContinuedFractionApproximationOfRoot(x^2-n,  periodlength);
  else approx := ContinuedFractionApproximationOfRoot(x^2-n,2*periodlength);
  fi;
  return [ NumeratorRat(approx), DenominatorRat(approx) ];
end;

</pre></div>

<p>First we determine the length of the period of the continued fraction expansion of the square root of <var class="Arg">n</var>. Then we determine the fundamental solution of Pell's equation by taking the numerator and the denominator of a suitable continued fraction approximation of that square root (note the dependency on the parity of the period length!). Examples are</p>


<div class="example"><pre>

gap&gt; FundamentalSolutionOfPellsEquation(2);
[ 3, 2 ]
gap&gt; FundamentalSolutionOfPellsEquation(5);
[ 9, 4 ]
gap&gt; FundamentalSolutionOfPellsEquation(13);
[ 649, 180 ]
gap&gt; FundamentalSolutionOfPellsEquation(15);
[ 4, 1 ]
gap&gt; FundamentalSolutionOfPellsEquation(61);
[ 1766319049, 226153980 ]

</pre></div>

<p>... and for <span class="SimpleMath">n = 421</span> we obtain</p>


<div class="example"><pre>

gap&gt; FundamentalSolutionOfPellsEquation(421);
[ 3879474045914926879468217167061449, 189073995951839020880499780706260 ]

</pre></div>

<p><a id="X81ACCC777887640E" name="X81ACCC777887640E"></a></p>

<h4>2.14 <span class="Heading">Automorphism Groups of Odd Order (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X83DD0C2C867A1DF0"><span class="RefLink">1.14</span></a>.</p>

<p>It suffices to look at groups of odd order: Assume that <span class="SimpleMath">G</span> is a group of even order, and let <span class="SimpleMath">G_2</span> be its Sylow 2-subgroup. If <span class="SimpleMath">G_2</span> is not a subgroup of the centre of <span class="SimpleMath">G</span>, then already the inner automorphism group has even order. If it is a subgroup of the centre of <span class="SimpleMath">G</span>, then we have <span class="SimpleMath">G = G_2 × G_2'</span>, and therefore Aut(<span class="SimpleMath">G</span>) = Aut(<span class="SimpleMath">G_2</span>) <span class="SimpleMath">×</span> Aut(<span class="SimpleMath">G_2'</span>). In this case, already the automorphism group of <span class="SimpleMath">G_2'</span> has odd order, and <span class="SimpleMath">G</span> is not the smallest group having this property.</p>

<p>We perform a <em>brute-force</em> search:</p>


<div class="example"><pre>

gap&gt; n := 3;;
gap&gt; repeat
&gt;      Print(n,"\n");
&gt;      G := First(AllGroups(n),G-&gt;Size(AutomorphismGroup(G)) mod 2 = 1);
&gt;      n := n + 2;
&gt;    until G &lt;&gt; fail;

</pre></div>

<p>This loop runs for quite a while. We obtain the following:</p>


<div class="example"><pre>

gap&gt; G;
&lt;pc group of size 729 with 6 generators&gt;
gap&gt; IdGroup(G);
[ 729, 31 ]
gap&gt; AutomorphismGroup(G);
&lt;group of size 19683 with 9 generators&gt;
gap&gt; StructureDescription(DerivedSubgroup(G));
"C9"
gap&gt; StructureDescription(G/DerivedSubgroup(G));
"C9 x C9"

</pre></div>

<p>The result that <span class="SimpleMath">3^6</span> is the smallest order of a group of more than 2 elements with an odd order automorphism group has first been obtained in <a href="chapBib.html#biBMacHaleSheehy95">[MS95]</a>.</p>

<p><a id="X7F3E7A848496D8DD" name="X7F3E7A848496D8DD"></a></p>

<h4>2.15 <span class="Heading">Composite Sums (Solution)</span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X7955A612871B3AAF"><span class="RefLink">1.15</span></a>.</p>

<p>First we look for odd integers <span class="SimpleMath">n</span> such that any sum <span class="SimpleMath">n+2^k</span> for "small" <span class="SimpleMath">k</span> has a "small" prime divisor:</p>


<div class="example"><pre>

gap&gt; m := Product(Primes);;
gap&gt; Filtered([1,3..99999],n-&gt;First([0..500],k-&gt;Gcd(n+2^k,m)=1)=fail);
[ 78557 ]

</pre></div>

<p>Now our goal is to find out whether in fact <em>all</em> sums <span class="SimpleMath">78557+2^k</span> are composite.</p>

<p>For this, we first determine the smallest prime factors of the numbers <span class="SimpleMath">78557+2^k</span> for "small" values of <span class="SimpleMath">k</span>. Then we find out for which <span class="SimpleMath">k</span> these primes <span class="SimpleMath">p_i</span> divide <span class="SimpleMath">78557+2^k</span>. The set of such <span class="SimpleMath">k</span> is the set of positive integers in a residue class modulo the order of 2 (mod <span class="SimpleMath">p_i</span>). Finally we form the union of the residue classes we obtain, and check whether it equals <span class="SimpleMath">Z</span> (this needs the <strong class="pkg">ResClasses</strong> package <a href="chapBib.html#biBResClasses">[Koh07c]</a>):</p>


<div class="example"><pre>

gap&gt; primes := Set([1..100],k-&gt;Minimum(Factors(Gcd(78557+2^k,m))));
[ 3, 5, 7, 13, 19, 37, 73 ]
gap&gt; m_i := List(primes,p-&gt;OrderMod(2,p));
[ 2, 4, 3, 12, 18, 36, 9 ]
gap&gt; r_i := List([1..Length(primes)],
&gt;                i-&gt;First([0..m_i[i]-1],k-&gt;(78557+2^k) mod primes[i] = 0));
[ 0, 3, 2, 1, 3, 9, 6 ]
gap&gt; residueclasses := List(TransposedMat([r_i,m_i]),ResidueClass);
[ 0(2), 3(4), 2(3), 1(12), 3(18), 9(36), 6(9) ]
gap&gt; Union(residueclasses);
Integers

</pre></div>

<p>Now we know that all sums <span class="SimpleMath">78557+2^k</span> for positive integers <span class="SimpleMath">k</span> are composite. But is 78557 indeed the smallest odd integer such that <span class="SimpleMath">n+2^k</span> is composite for all positive integers <span class="SimpleMath">k</span>? -- Likely yes, but answering this question is computationally difficult:</p>


<div class="example"><pre>

gap&gt; k_s := List([1,3..78557],
&gt;                n-&gt;First([1..1000],k-&gt;IsProbablyPrimeInt(n+2^k)));;
gap&gt; k_s{[1..100]}; # small n are not a problem ...
[ 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 3, 2, 1, 1, 4, 2, 1, 2, 1, 1, 2, 1, 5, 2, 
  1, 3, 2, 1, 1, 8, 2, 1, 2, 1, 1, 4, 2, 1, 2, 1, 7, 2, 1, 3, 4, 2, 1, 2, 1, 
  1, 2, 1, 1, 2, 1, 7, 4, 5, 3, 4, 2, 1, 2, 1, 3, 2, 1, 1, 10, 3, 3, 2, 1, 1, 
  4, 2, 1, 4, 2, 1, 2, 1, 5, 2, 1, 3, 2, 1, 1, 4, 3, 3, 2, 1, 1, 2, 1, 1, 6 ]
gap&gt; 2*Positions(k_s,fail)-1; # ... but larger n are:
[ 2131, 2491, 4471, 5101, 6379, 6887, 7013, 8447, 8543, 9833, 10711, 14033, 
  14551, 14573, 14717, 15623, 16519, 17659, 18527, 19081, 19249, 20209, 
  20273, 21143, 21661, 22193, 23147, 23221, 23971, 24953, 26213, 26491, 
  28433, 29333, 29777, 30197, 31111, 31369, 31951, 32449, 32513, 34429, 
  35461, 36083, 36721, 37217, 37967, 38387, 39079, 40291, 40351, 40613, 
  41453, 41693, 43579, 47269, 48091, 48331, 48527, 48859, 48961, 49279, 
  49577, 50839, 52339, 53119, 53359, 56717, 57083, 59071, 60443, 60451, 
  60947, 60961, 62029, 63691, 64133, 64643, 65033, 65089, 65719, 67607, 
  69593, 69709, 70321, 72679, 73373, 73583, 75353, 75841, 77041, 77783, 
  77899, 78557 ]

</pre></div>

<p>Using a bound larger than 1000 for <span class="SimpleMath">k</span>, it is possible to eliminate many of the above values of <span class="SimpleMath">n</span>, but eliminating all of them except of 78557 seems hard.</p>

<p>See also the related term <span class="URL"><a href="http://en.wikipedia.org/wiki/Sierpinski_number ">Sierpinski number</a></span>, and the corresponding distributed computing project <span class="URL"><a href=" http://www.rechenkraft.net/wiki/index.php?title=Seventeen_or_bust">Seventeen or bust</a></span>.</p>

<p>The interested reader might have a look at the similar problem with Fibonacci numbers instead of powers of 2.</p>

<p><a id="X86BFAFD781969442" name="X86BFAFD781969442"></a></p>

<h4>2.16 <span class="Heading">Rational Points on the Unit Sphere (Solution) </span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X84DD47D37DD483E4"><span class="RefLink">1.16</span></a>.</p>

<p>The function can be written as follows:</p>


<div class="example"><pre>

RationalPointsOnUnitSphere := function ( max_abc, size, filename )

  local  picture, solutions, a, b, c, d, sum,
         pixelcoords, mirror, zero, one, i, j;

  zero := Zero(GF(2)); one := One(GF(2)); # create a white picture:
  picture := NullMat(size,size,GF(2));
  for i in [1..size] do for j in [1..size] do picture[i][j] := one; od; od;

  solutions := 0;
  for a in [1..max_abc] do
    Print("a = ",a,", #solutions = ",solutions,"\n");
    for b in [1..a] do
      for c in [1..b] do
        sum := a^2 + b^2 + c^2;
        d   := RootInt(sum);
        if d^2 = sum then
          pixelcoords := List( size * [a,b,c]/d, Int ) + 1;
          for mirror in Arrangements([1..3],2) do
            picture[pixelcoords[mirror[1]]][pixelcoords[mirror[2]]] := zero;
          od;
          solutions := solutions + 1;
        fi;
      od;
    od;
  od;
  SaveAsBitmapPicture(picture,filename);
end;

</pre></div>

<p>With some patience, you can use this function to produce a picture like <span class="URL"><a href=" http://www.cip.mathematik.uni-stuttgart.de/~kohlsn/images/sphere1.gif">this</a></span>.</p>

<p><a id="X8719302881C72AB2" name="X8719302881C72AB2"></a></p>

<h4>2.17 <span class="Heading">Aliquot Sequences (Solution) </span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X85C3564D79898089"><span class="RefLink">1.17</span></a>.</p>

<p>We can write the following <strong class="pkg">GAP</strong> function:</p>


<div class="example"><pre>

AliquotSequence := function ( n )

  local  a, i;

  a := [n]; i := 1;
  while a[i] &gt; 1 and not a[i] in a{[1..i-1]} do
    a[i+1] := Sigma(a[i]) - a[i]; i := i + 1;
  od;
  return a;
end;

</pre></div>

<p>This yields the following:</p>


<div class="example"><pre>

gap&gt; List([1..40],AliquotSequence);
[ [ 1 ], [ 2, 1 ], [ 3, 1 ], [ 4, 3, 1 ], [ 5, 1 ], [ 6, 6 ], [ 7, 1 ], 
  [ 8, 7, 1 ], [ 9, 4, 3, 1 ], [ 10, 8, 7, 1 ], [ 11, 1 ], 
  [ 12, 16, 15, 9, 4, 3, 1 ], [ 13, 1 ], [ 14, 10, 8, 7, 1 ], 
  [ 15, 9, 4, 3, 1 ], [ 16, 15, 9, 4, 3, 1 ], [ 17, 1 ], [ 18, 21, 11, 1 ], 
  [ 19, 1 ], [ 20, 22, 14, 10, 8, 7, 1 ], [ 21, 11, 1 ], 
  [ 22, 14, 10, 8, 7, 1 ], [ 23, 1 ], [ 24, 36, 55, 17, 1 ], [ 25, 6, 6 ], 
  [ 26, 16, 15, 9, 4, 3, 1 ], [ 27, 13, 1 ], [ 28, 28 ], [ 29, 1 ], 
  [ 30, 42, 54, 66, 78, 90, 144, 259, 45, 33, 15, 9, 4, 3, 1 ], [ 31, 1 ], 
  [ 32, 31, 1 ], [ 33, 15, 9, 4, 3, 1 ], [ 34, 20, 22, 14, 10, 8, 7, 1 ], 
  [ 35, 13, 1 ], [ 36, 55, 17, 1 ], [ 37, 1 ], [ 38, 22, 14, 10, 8, 7, 1 ], 
  [ 39, 17, 1 ], [ 40, 50, 43, 1 ] ]
gap&gt; List([1..275],n-&gt;Length(AliquotSequence(n)));
[ 1, 2, 2, 3, 2, 2, 2, 3, 4, 4, 2, 7, 2, 5, 5, 6, 2, 4, 2, 7, 3, 6, 2, 5, 3, 
  7, 3, 2, 2, 15, 2, 3, 6, 8, 3, 4, 2, 7, 3, 4, 2, 14, 2, 5, 7, 8, 2, 6, 4, 
  3, 4, 9, 2, 13, 3, 5, 3, 4, 2, 11, 2, 9, 3, 4, 3, 12, 2, 5, 4, 6, 2, 9, 2, 
  5, 5, 5, 3, 11, 2, 7, 5, 6, 2, 6, 3, 9, 7, 7, 2, 10, 4, 6, 4, 4, 4, 9, 2, 
  3, 4, 5, 2, 18, 2, 7, 8, 6, 2, 10, 2, 7, 3, 9, 2, 17, 3, 5, 4, 10, 4, 12, 
  8, 5, 8, 6, 3, 16, 2, 3, 3, 6, 2, 11, 4, 7, 9, 8, 2, 178, 2, 5, 5, 6, 4, 9, 
  4, 6, 6, 11, 2, 177, 2, 12, 6, 8, 3, 8, 2, 7, 4, 11, 3, 4, 2, 7, 9, 10, 2, 
  175, 6, 9, 3, 9, 2, 16, 3, 5, 4, 7, 2, 52, 2, 9, 4, 6, 3, 15, 3, 12, 3, 10, 
  2, 13, 2, 6, 6, 4, 2, 14, 2, 4, 3, 8, 3, 10, 3, 7, 9, 7, 3, 52, 2, 11, 6, 
  8, 5, 10, 4, 10, 4, 3, 3, 176, 2, 17, 8, 6, 2, 8, 2, 9, 7, 11, 2, 175, 3, 
  7, 3, 7, 2, 11, 2, 3, 9, 11, 3, 15, 7, 12, 8, 11, 2, 17, 4, 7, 5, 6, 2, 14, 
  8, 11, 4, 8, 2, 31, 3, 9, 5, 8, 2, 13, 2, 12, 4, 6, 3 ]
gap&gt; Maximum(last);
178
gap&gt; Position(last2,last);
138
gap&gt; AliquotSequence(138);
[ 138, 150, 222, 234, 312, 528, 960, 2088, 3762, 5598, 6570, 10746, 13254, 
  13830, 19434, 20886, 21606, 25098, 26742, 26754, 40446, 63234, 77406, 
  110754, 171486, 253458, 295740, 647748, 1077612, 1467588, 1956812, 2109796, 
  1889486, 953914, 668966, 353578, 176792, 254128, 308832, 502104, 753216, 
  1240176, 2422288, 2697920, 3727264, 3655076, 2760844, 2100740, 2310856, 
  2455544, 3212776, 3751064, 3282196, 2723020, 3035684, 2299240, 2988440, 
  5297320, 8325080, 11222920, 15359480, 19199440, 28875608, 25266172, 
  19406148, 26552604, 40541052, 54202884, 72270540, 147793668, 228408732, 
  348957876, 508132204, 404465636, 303708376, 290504024, 312058216, 
  294959384, 290622016, 286081174, 151737434, 75868720, 108199856, 101437396, 
  76247552, 76099654, 42387146, 21679318, 12752594, 7278382, 3660794, 
  1855066, 927536, 932464, 1013592, 1546008, 2425752, 5084088, 8436192, 
  13709064, 20563656, 33082104, 57142536, 99483384, 245978376, 487384824, 
  745600776, 1118401224, 1677601896, 2538372504, 4119772776, 8030724504, 
  14097017496, 21148436904, 40381357656, 60572036544, 100039354704, 
  179931895322, 94685963278, 51399021218, 28358080762, 18046051430, 
  17396081338, 8698040672, 8426226964, 6319670230, 5422685354, 3217383766, 
  1739126474, 996366646, 636221402, 318217798, 195756362, 101900794, 
  54202694, 49799866, 24930374, 17971642, 11130830, 8904682, 4913018, 
  3126502, 1574810, 1473382, 736694, 541162, 312470, 249994, 127286, 69898, 
  34952, 34708, 26038, 13994, 7000, 11720, 14740, 19532, 16588, 18692, 14026, 
  7016, 6154, 3674, 2374, 1190, 1402, 704, 820, 944, 916, 694, 350, 394, 200, 
  265, 59, 1 ]

</pre></div>

<p>Thus we see that indeed all Aliquot sequences starting at integers <span class="SimpleMath">n ≤ 275</span> either stop or run into cycles. So far, everything runs quickly and there are no performance problems of any kind. However, <span class="SimpleMath">n = 276</span> causes severe problems -- the sequence grows, and factoring becomes a serious problem. As suggested in the hints, we install the following modified <strong class="pkg">GAP</strong> Library method for the operation <code class="code">Sigma</code> to ensure that <strong class="pkg">FactInt</strong> <a href="chapBib.html#biBFactInt">[Koh07a]</a> is used for factoring integers:</p>


<div class="example"><pre>

InstallMethod( Sigma, "use FactInt", true, [ IsPosInt ], SUM_FLAGS,

  function( n )

    local  sigma, p, q, k;

    # make &lt;n&gt; it nonnegative, handle trivial cases
    if n &lt; 0 then n := -n; fi;
    if n = 0 then Error("Sigma: &lt;n&gt; must not be 0"); fi;
    if n &lt;= Length(DivisorsIntCache) then
      return Sum(DivisorsIntCache[n]);
    fi;

    # loop over all prime factors p of n
    sigma := 1;
    for p in Set(Factors(n)) do

      # compute p^e and k = 1+p+p^2+..p^e
      q := p;  k := 1 + p;
      while n mod (q * p) = 0 do q := q * p; k := k + q; od;
   
      # combine with the value found so far
      sigma := sigma * k;

    od;

    return sigma;
  end );

</pre></div>

<p>Further we insert a <code class="code">Print</code> statement into our <code class="code">AliquotSequence</code> function, and we switch on <strong class="pkg">FactInt</strong>'s <code class="code">Info</code>'s whenever large integers are to be factored:</p>


<div class="example"><pre>

AliquotSequence := function ( n )

  local  a, i;

  a := [n]; i := 1;
  while a[i] &gt; 1 and not a[i] in a{[1..i-1]} do
    if a[i] &gt; 10^40 then FactIntInfo(3); fi;
    Factors(a[i]);
    FactIntInfo(0);
    Print(String(i,6)," : ",a[i]," = ");
    PrintFactorsInt(a[i]); Print("\n");
    a[i+1] := Sigma(a[i]) - a[i];
    i := i + 1;
  od;
  return a;
end;

</pre></div>

<p>Now try out yourself how far you can get with computing the <span class="URL"><a href=" http://en.wikipedia.org/wiki/Aliquot_sequence">Aliquot sequence</a></span> starting at 276 ... !</p>

<p><a id="X7F9840A8797DA032" name="X7F9840A8797DA032"></a></p>

<h4>2.18 <span class="Heading">The Q Sequence (Solution) </span></h4>

<p>This is a suggested solution for Exercise <a href="chap1.html#X7AC6CF047AF04240"><span class="RefLink">1.18</span></a>.</p>


<dl>
<dt><strong class="Mark">ad a)</strong></dt>
<dd><p>We can write either the following recursive</p>


<div class="example"><pre>

Q := function ( n )
  if   n in [1,2]
  then return 1;
  else return Q(n-Q(n-1)) + Q(n-Q(n-2)); fi;
end;
QSequence := l -&gt; List([1..l],Q);

</pre></div>

<p>or the following iterative code;</p>


<div class="example"><pre>

QSequence := function ( l )

  local  Q, n;

  Q := [1,1];
  for n in [3..l] do
    Q[n] := Q[n-Q[n-1]] + Q[n-Q[n-2]];
  od;
  return Q;
end;

</pre></div>

<p>With the recursive approach, we get something like the following timings:</p>


<div class="example"><pre>

gap&gt; QSequence(10);
[ 1, 1, 2, 3, 3, 4, 5, 5, 6, 6 ]
gap&gt; time;
0
gap&gt; QSequence(20);
[ 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12 ]
gap&gt; time;
220
gap&gt; QSequence(30);
[ 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12, 12, 12, 
  12, 16, 14, 14, 16, 16, 16, 16 ]
gap&gt; time;
26640

</pre></div>

<p>Thus we observe a horrible increase in runtime. With the iterative approach, this looks quite different:</p>


<div class="example"><pre>

gap&gt; QSequence(200);
[ 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12, 12, 12, 
  12, 16, 14, 14, 16, 16, 16, 16, 20, 17, 17, 20, 21, 19, 20, 22, 21, 22, 23, 
  23, 24, 24, 24, 24, 24, 32, 24, 25, 30, 28, 26, 30, 30, 28, 32, 30, 32, 32, 
  32, 32, 40, 33, 31, 38, 35, 33, 39, 40, 37, 38, 40, 39, 40, 39, 42, 40, 41, 
  43, 44, 43, 43, 46, 44, 45, 47, 47, 46, 48, 48, 48, 48, 48, 48, 64, 41, 52, 
  54, 56, 48, 54, 54, 50, 60, 52, 54, 58, 60, 53, 60, 60, 52, 62, 66, 55, 62, 
  68, 62, 58, 72, 58, 61, 78, 57, 71, 68, 64, 63, 73, 63, 71, 72, 72, 80, 61, 
  71, 77, 65, 80, 71, 69, 77, 75, 73, 77, 79, 76, 80, 79, 75, 82, 77, 80, 80, 
  78, 83, 83, 78, 85, 82, 85, 84, 84, 88, 83, 87, 88, 87, 86, 90, 88, 87, 92, 
  90, 91, 92, 92, 94, 92, 93, 94, 94, 96, 94, 96, 96, 96, 96, 96, 96, 128, 
  72, 96, 115, 100, 84, 114, 110, 93 ]
gap&gt; time;
0

</pre></div>

<p>Let's have a look how often <code class="code">Q</code> calls itself in the recursive version:</p>


<div class="example"><pre>

QCallCounts := function ( n )

  local  Q, sequence;

  Q := function ( n )
    sequence[n] := sequence[n] + 1;
    if   n in [1,2]
    then return 1;
    else return Q(n-Q(n-1)) + Q(n-Q(n-2)); fi;
  end;

  sequence := ListWithIdenticalEntries(n,0);
  Q(n);
  return sequence;
end;

</pre></div>

<p>We obtain</p>


<div class="example"><pre>

gap&gt; QCallCounts(30);
[ 1477421, 5444369, 1477421, 415342, 181422, 98727, 55073, 31366, 18752, 
  11250, 6884, 4238, 2604, 1601, 987, 610, 377, 233, 144, 89, 55, 34, 21, 13, 
  8, 5, 3, 2, 1, 1 ]

</pre></div>

<p>This clearly explains the poor performance. (By the way: The end of the sequence seems to be the reversed beginning of the sequence of Fibonacci numbers -- can you find out something about this?)</p>

</dd>
<dt><strong class="Mark">ad b)</strong></dt>
<dd><p>We can write the following <strong class="pkg">GAP</strong> function:</p>


<div class="example"><pre>

PlotQSequence := function ( l, filename )

  local  Q, graph, h, n, i, j, zero, one;

  Q := QSequence(l);
  h := Maximum(Q); # use the maximum as the height of the picture
  graph := NullMat(h,l);
  zero := Zero(GF(2)); one := One(GF(2));
  for i in [1..h] do for j in [1..l] do graph[i][j] := one; od; od;
  for n in [1..l] do graph[Q[n]][n] := zero; od;
  SaveAsBitmapPicture(graph,filename);
end;

</pre></div>

</dd>
</dl>

<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
