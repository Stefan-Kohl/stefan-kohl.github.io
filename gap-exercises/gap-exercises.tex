% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}



\usepackage{amsxtra}

%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{GAP Exercises\mbox{}}}\\
\vfill

\hypersetup{pdftitle=GAP Exercises}
\markright{\scriptsize \mbox{}\hfill GAP Exercises \hfill\mbox{}}
{\Huge \textbf{\mbox{}}}\\
\vfill

{\Huge  Version 1.0 \mbox{}}\\[1cm]
{February 17, 2010\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Stefan Kohl    \mbox{}}}\\
\hypersetup{pdfauthor= Stefan Kohl    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Stefan Kohl    }  Email: \href{mailto://stefan@mcs.st-and.ac.uk} {\texttt{stefan@mcs.st-and.ac.uk}}\\
  Homepage: \href{ http://www.gap-system.org/DevelopersPages/StefanKohl/ } {\texttt{ http://www.gap-system.org/DevelopersPages/StefanKohl/ }}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Mathematics \\
 University of Vlora \\
 Lagjja: Pavaresia \\
 Vlore / Albania \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 1 ]}}

\tableofcontents
\newpage

      
\chapter{\textcolor{Chapter }{The Exercises}}\label{ch:Exercises}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X85B3C51378570E47}{}
{
  
\section{\textcolor{Chapter }{On Commutators and Derived Subgroups}}\label{sec:CommutatorExercise}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X83B2FD4187C233D7}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:CommutatorExercise}
\logpage{[ 1, 1, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{group@group!derived subgroup} \index{group@group!commutator} \index{derived subgroup@derived subgroup} \index{commutator@commutator} The \emph{derived subgroup} $G'$ of a group $G$ is defined as the group \emph{generated} by all \emph{commutators} $[a,b] := a^{-1}b^{-1}ab$, where $a,b \in G$. In general, not all elements of the derived subgroup of a group are actually
commutators themselves. Find a group $G$ of smallest possible order such that the set of all commutators of elements of $G$ does not \emph{form} a group! 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:CommutatorHints}
\logpage{[ 1, 1, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Comm@\texttt{Comm}} \index{DerivedSubgroup@\texttt{DerivedSubgroup}} \index{Cartesian@\texttt{Cartesian}} \index{Set@\texttt{Set}} \index{AsList@\texttt{AsList}} \index{CommutatorLength@\texttt{CommutatorLength}} Commutators can be computed by the operation \texttt{Comm}, and the derived subgroup can be computed by the operation \texttt{DerivedSubgroup}. The function \texttt{Cartesian} and the operations \texttt{Set} and \texttt{AsList} can be helpful in this context as well. If you are lazy but patient, you may
simply use \texttt{CommutatorLength}. Otherwise, this exercise requires writing a couple of lines of \textsf{GAP} code. The wanted group has order greater than{\nobreakspace}50, but less
than{\nobreakspace}100. 

 For a solution, see Section{\nobreakspace}\ref{sec:CommutatorSolution}. }

 }

  
\section{\textcolor{Chapter }{On Outer Automorphisms Fixing Conjugacy Classes}}\label{sec:OuterAutomorphismsExercise}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X86A6B9EB848804CB}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:OuterAutomorphismsExercise}
\logpage{[ 1, 2, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{group@group!outer automorphism} \index{group@group!conjugacy class} \index{outer automorphism@outer automorphism} \index{conjugacy class@conjugacy class} Is there a finite group which has an automorphism which is not inner, but
which nevertheless fixes all conjugacy classes setwise? -- If so, then find an
example of least possible order! 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:OuterAutomorphismsHints}
\logpage{[ 1, 2, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{AllGroups@\texttt{AllGroups}} \index{AutomorphismGroup@\texttt{AutomorphismGroup}} \index{IsInnerAutomorphism@\texttt{IsInnerAutomorphism}} \index{IsConjugate@\texttt{IsConjugate}} \index{Image@\texttt{Image}} \index{AsList@\texttt{AsList}} This exercise is slightly more difficult than that given in
Section{\nobreakspace}\ref{sec:CommutatorExercise}. Useful functions and operations are \texttt{AllGroups}, \texttt{AutomorphismGroup}, \texttt{IsInnerAutomorphism}, \texttt{IsConjugate}, \texttt{Image} and \texttt{AsList}. It is a good exercise to try to find a way to write down the group and the
automorphism in a nice and human-readable form. One possible way to achieve
this is to determine a ``nice'' permutation representation of the group, and to choose an automorphism with
the desired property which fixes all but one of the generators. 

 For a solution, see Section{\nobreakspace}\ref{sec:OuterAutomorphismsSolution}. }

 }

  
\section{\textcolor{Chapter }{Drawing the Ulam Spiral}}\label{sec:UlamSpiralExercise}
\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X8021163B7AA10C83}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:UlamSpiralExercise}
\logpage{[ 1, 3, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{Ulam spiral@Ulam spiral} \index{prime number@prime number} \index{graphics@graphics} Write a \textsf{GAP} function which draws the \href{http://en.wikipedia.org/wiki/Ulam_spiral} {Ulam spiral} and saves the picture in a file! 

 The arguments of the function should be the size (width / height) of the
picture to be drawn and the name of the output file. 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:UlamSpiralHints}
\logpage{[ 1, 3, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{NullMat@\texttt{NullMat}} \index{SaveAsBitmapPicture@\texttt{SaveAsBitmapPicture}} \index{RCWA package@RCWA package} This is more or less just an easy programming exercise, which does not require
particular mathematical knowledge. Use the function \texttt{NullMat} to create a zero matrix over the field with two elements, and use this matrix
as a grid to draw the spiral. The \textsf{RCWA} package{\nobreakspace}\cite{RCWA} provides a function \texttt{SaveAsBitmapPicture}, which can be used to produce a picture file from the matrix. 

 For a solution, see Section{\nobreakspace}\ref{sec:UlamSpiralSolution}. }

 }

  
\section{\textcolor{Chapter }{Automorphism Group of the Smallest Projective Plane}}\label{sec:ProjectivePlaneExercise}
\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X858A19237E85E12C}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:ProjectivePlaneExercise}
\logpage{[ 1, 4, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{projective plane@projective plane!automorphism group} The automorphisms of a finite projective plane are determined by the
permutations of the set of points which move lines to lines. Thus, labelling
the points with integers $1, 2, \dots, n$, the automorphism group can be described as a subgroup of the symmetric group ${\rm S}_n$. 

 The smallest projective plane has 7 points and 7 lines. Any point is incident
with 3 lines, and any line is incident with 3 points. We label the points with
integers $1, 2, \dots, 7$. Then the lines are given by the sets $g_1 := \{1,2,3\}$, $g_2 := \{1,4,7\}$, $g_3 := \{1,5,6\}$, $g_4 := \{2,4,6\}$, $g_5 := \{2,5,7\}$, $g_6 := \{3,4,5\}$ and $g_7 := \{3,6,7\}$ of points which are incident with them. 

 Compute the automorphism group of the smallest projective plane! 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:ProjectivePlaneHints}
\logpage{[ 1, 4, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{SubgroupProperty@\texttt{SubgroupProperty}} A useful function in this context is \texttt{SubgroupProperty}. The actual determination of the group can be done in one statement. Can you
figure out the isomorphism type of the group by theoretical means? 

 For a solution, see Section{\nobreakspace}\ref{sec:ProjectivePlaneSolution}. }

 }

  
\section{\textcolor{Chapter }{Installing a Missing Method}}\label{sec:InstallingMethodsExercise}
\logpage{[ 1, 5, 0 ]}
\hyperdef{L}{X7E8BCAC78695DB80}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:InstallingMethodsExercise}
\logpage{[ 1, 5, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{method installation@method installation} \index{Centre@\texttt{Centre}} \index{AlternatingGroup@\texttt{AlternatingGroup}} What happens when you enter the command \texttt{Centre(AlternatingGroup(100));} in{\nobreakspace}\textsf{GAP}? Are you satisfied with the performance, given that the centre of a
nonabelian simple group is always trivial and that \textsf{GAP} knows that the alternating group of degree{\nobreakspace}100 is simple? 

 Probably not. -- Thus improve the performance radically by implementing a
method for \texttt{Centre} for simple groups, which returns either the group itself or the trivial
subgroup, depending on whether the group is abelian or not! 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:InstallingMethodsHints}
\logpage{[ 1, 5, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{InstallMethod@\texttt{InstallMethod}} Methods are installed with \texttt{InstallMethod}. The exercise is easy -- basically all you need to do is to look up in the
documentation how this function is used. If your solution is correct, then \texttt{Centre(AlternatingGroup(100));} returns the trivial subgroup immediately, and \texttt{Centre(\mbox{\texttt{\mdseries\slshape G}})} still computes the centre of a non-simple group \mbox{\texttt{\mdseries\slshape G}} using methods implemented in the \textsf{GAP} Library. 

 For a solution, see Section{\nobreakspace}\ref{sec:InstallingMethodsSolution}. }

 }

  
\section{\textcolor{Chapter }{Finding Good abc Triples}}\label{sec:abcTriplesExercise}
\logpage{[ 1, 6, 0 ]}
\hyperdef{L}{X875EE5997CA845C5}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:abcTriplesExercise}
\logpage{[ 1, 6, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{abc conjecture@abc conjecture} \index{abc triples@abc triples} Given a positive integer $n$, let rad($n$) denote the product of distinct prime divisors of{\nobreakspace}$n$. The \href{http://en.wikipedia.org/wiki/Abc_conjecture} {abc conjecture} states that for any $\epsilon > 0$ there is a constant $K_\epsilon$ such that for any triple $(a,b,c)$ of coprime positive integers satisfying the equation $a + b = c$ we have $c < K_\epsilon {\rm rad}(abc)^{1 + \epsilon}$. 

 A triple $(a,b,c)$ of coprime integers satisfying $a + b = c$ is called an \emph{abc triple} if rad($abc$) is less than{\nobreakspace}$c$. An abc triple $(a,b,c)$ is called a \emph{good} abc triple if it satisfies even $\ln(c)/\ln({\rm rad}(abc)) > 1.4$. The left-hand side of the inequality is sometimes called the \emph{ratio} of the abc triple. 

 It can be shown easily that there are infinitely many abc triples, but if the
abc conjecture holds, there are only finitely many good abc triples. 

 Write a \textsf{GAP} function which finds all good abc triples $(a,b,c)$ with given radical rad($abc$) and with $c$ less than a given bound! 

 Can you find a new triple, which is not yet on Abderrahmane Nitaj's \href{ http://www.math.unicaen.fr/~nitaj/tableabc.pdf} {list of known good abc triples}? 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:abcTriplesHints}
\logpage{[ 1, 6, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Float@\texttt{Float}} \index{LOG_FLOAT@\texttt{LOG{\textunderscore}FLOAT}} You can start by determining all positive integers less than the given bound
all of whose prime factors divide the given radical. This can be done much
more efficiently than by the Sieve of Eratosthenes, or even by looping over
all integers in the range and factoring -- it is easy and very elementary to
find out how. Then you can loop over all pairs of these integers, test whether
they are coprime and compute the ratio if they are. To compute the ratio, you
need the operation \texttt{Float} which converts integers and rationals to floating point numbers, and the
function \texttt{LOG{\textunderscore}FLOAT} which computes the natural logarithm of a floating point number. 

 For a solution, see Section{\nobreakspace}\ref{sec:abcTriplesSolution}. }

 }

  
\section{\textcolor{Chapter }{Automorphism Groups of Finite Graphs}}\label{sec:GraphsExercise}
\logpage{[ 1, 7, 0 ]}
\hyperdef{L}{X84042AFF837539CC}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:GraphsExercise}
\logpage{[ 1, 7, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{graph@graph!finite, undirected} \index{graph@graph!automorphism group} \index{graph@graph!isomorphism type} 
\begin{description}
\item[{a)}]  Determine all undirected graphs with 6 vertices up to isomorphism! -- How many
isomorphism types of such graphs are there? 

 The graphs should be represented as sets of edges, where the edges should be
written as sets of two vertices, each. 

 Example: In this representation, the graphs \texttt{[[1,2],[1,6],[2,3],[3,4],[4,5],[5,6]]} and \texttt{[[1,5],[1,6],[2,4],[2,6],[3,4],[3,5]]} are both isomorphic to the regular hexagon. 
\item[{b)}]  Write a function \texttt{GraphAutomorphismGroup(\mbox{\texttt{\mdseries\slshape Gamma}},\mbox{\texttt{\mdseries\slshape n}})} which computes the automorphism group of the graph \mbox{\texttt{\mdseries\slshape Gamma}} with \mbox{\texttt{\mdseries\slshape n}} vertices. -- The automorphisms are precisely the permutations of the set of
vertices which move edges to edges. 

 Note that the cardinality \mbox{\texttt{\mdseries\slshape n}} of the set of vertices needs to be specified, as there may be isolated
vertices. 
\item[{c)}]  Find out which of the (up to conjugation in ${\rm S}_6$) 16 transitive permutation groups of degree{\nobreakspace}6 occur as
automorphism groups of graphs with 6 vertices! -- How do the corresponding
graphs look like? 
\end{description}
 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:GraphsHints}
\logpage{[ 1, 7, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Combinations@\texttt{Combinations}} \index{Orbits@\texttt{Orbits}} \index{Representative@\texttt{Representative}} \index{SubgroupProperty@\texttt{SubgroupProperty}} \index{AllTransitiveGroups@\texttt{AllTransitiveGroups}} \index{NrMovedPoints@\texttt{NrMovedPoints}} \index{TransitiveIdentification@\texttt{TransitiveIdentification}} 
\begin{description}
\item[{ad a)}]  You can obtain the set of all graphs with $n$ vertices in the suggested notation by \texttt{Combinations(Combinations([1..n],2));}. Then you need to find a suitable group action on this set such that two
graphs are isomorphic if and only if they lie in the same orbit. Useful
operations are \texttt{Orbits} and \texttt{Representative}. 
\item[{ad b)}]  In principle you can implement a fancy algorithm here, but for our purposes a
very basic one is perfectly sufficient. First find out how to check whether a
given permutation of the vertices induces a graph automorphism. Then you can
use \texttt{SubgroupProperty} to determine the group formed by all such permutations. 
\item[{ad c)}]  Given Part{\nobreakspace}a) and{\nobreakspace}b), this is more or less
straightforward. Useful functions / operations are \texttt{AllTransitiveGroups}, \texttt{NrMovedPoints} and \texttt{TransitiveIdentification}. 
\end{description}
 For a solution, see Section{\nobreakspace}\ref{sec:GraphsSolution}. }

 }

  
\section{\textcolor{Chapter }{Enumerating Paths}}\label{sec:EnumeratingPathsExercise}
\logpage{[ 1, 8, 0 ]}
\hyperdef{L}{X7CCCEDEF79312B71}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:EnumeratingPathsExercise}
\logpage{[ 1, 8, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{transposition@transposition} \index{chess board@chess board} Answer the following questions using \textsf{GAP}: 
\begin{description}
\item[{a)}]  In how many ways can $1 \in {\rm S}_4$ be written as a product of exactly 100 transpositions? 
\item[{b)}]  In how many ways can a horse cross the chess board from the upper left to the
lower right corner with exactly 100 moves? 
\end{description}
 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:EnumeratingPathsHints}
\logpage{[ 1, 8, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{NullMat@\texttt{NullMat}} \index{SymmetricGroup@\texttt{SymmetricGroup}} \index{Combinations@\texttt{Combinations}} \index{Cartesian@\texttt{Cartesian}} \index{Position@\texttt{Position}} Construct a matrix $x \in \mathbb{Z}^{n \times n}$ with ones at suitable positions and zeros everywhere else and compute powers.
For Part{\nobreakspace}a), choose $n := 24$, and for Part{\nobreakspace}b), choose $n := 8^2 = 64$. Useful functions are e.g. \texttt{NullMat}, \texttt{SymmetricGroup}, \texttt{Combinations}, \texttt{Cartesian} and \texttt{Position}. 

 For a solution, see Section{\nobreakspace}\ref{sec:EnumeratingPathsSolution}. }

 }

  
\section{\textcolor{Chapter }{Wieferich Primes}}\label{sec:WieferichPrimesExercise}
\logpage{[ 1, 9, 0 ]}
\hyperdef{L}{X81B0B3817B0A915E}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:WieferichPrimesExercise}
\logpage{[ 1, 9, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{Wieferich prime@Wieferich prime} By Fermat's little theorem, for any prime number $p$ we have $p|2^{p-1}-1$. A prime number $p$ is called a \href{http://en.wikipedia.org/wiki/Wieferich_prime } {Wieferich prime} if it satisfies even $p^2|2^{p-1}-1$. 

 Write a \textsf{GAP} function which checks whether a given positive integer is a Wieferich prime,
and try to find as many Wieferich primes as you can! 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:WieferichPrimesHints}
\logpage{[ 1, 9, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{PowerModInt@\texttt{PowerModInt}} Writing the \textsf{GAP} function is easy. Use \texttt{PowerModInt} instead of first computing $2^{p-1}$ and then reducing modulo{\nobreakspace}$p^2$. Two Wieferich primes can be found easily, but finding a third one is at
least hard. 

 For a solution, see Section{\nobreakspace}\ref{sec:WieferichPrimesSolution}. }

 }

  
\section{\textcolor{Chapter }{Counting Words in a File}}\label{sec:WordCountExercise}
\logpage{[ 1, 10, 0 ]}
\hyperdef{L}{X7EA102507FD3E28D}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:WordCountExercise}
\logpage{[ 1, 10, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{stream@stream} \index{string@string} \index{word count@word count} Write a \textsf{GAP} function which, given a filename, returns a word distribution statistics. The
function should return a list with entries of the form \texttt{[ "word", 237 ]} for any word in the file, indicating the word and the number of times it
occurs. A ``word'' in our sense is a sequence of letters with no non-letter characters in
between, i.e. it does not need to be a dictionary word. Can you put your
function into one line with no more than 80 characters? 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:WordCountHints}
\logpage{[ 1, 10, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Collected@\texttt{Collected}} \index{StringFile@\texttt{StringFile}} \index{WordsString@\texttt{WordsString}} \index{GAPDoc package@GAPDoc package} You will probably need the operation \texttt{Collected}. Further, the functions \texttt{StringFile} and \texttt{WordsString} from the \textsf{GAPDoc} package{\nobreakspace}\cite{GAPDoc} will be useful. 

 For a solution, see Section{\nobreakspace}\ref{sec:WordCountSolution}. }

 }

  
\section{\textcolor{Chapter }{Non-Metabelian p-Groups}}\label{sec:NonMetabelianPGroupsExercise}
\logpage{[ 1, 11, 0 ]}
\hyperdef{L}{X8184A6AF7A47566C}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:NonMetabelianPGroupsExercise}
\logpage{[ 1, 11, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{group@group!metabelian group} \index{group@group!p-group} \index{metabelian group@metabelian group} \index{p-group@p-group} A group $G$ is called \emph{metabelian} if it has an abelian normal subgroup $N$ such that the quotient $G/N$ is abelian as well. Further, a group is called a \emph{$p$-group} if its order is a power of a prime. 

 Find a non-metabelian $p$-group of least possible order! 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:NonMetabelianPGroupsHints}
\logpage{[ 1, 11, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Small Groups Library@Small Groups Library} \index{AllGroups@\texttt{AllGroups}} \index{DerivedSubgroup@\texttt{DerivedSubgroup}} \index{IsAbelian@\texttt{IsAbelian}} First determine conceivable orders of non-metabelian groups by means of
theory. Then just run a \emph{brute-force} search over the groups of the smallest few of these orders in the Small Groups
Library{\nobreakspace}\cite{SmallGroups}. Useful functions / operations are \texttt{AllGroups}, \texttt{DerivedSubgroup} and \texttt{IsAbelian}. For a solution, see Section{\nobreakspace}\ref{sec:NonMetabelianPGroupsSolution}. }

 }

  
\section{\textcolor{Chapter }{The Growth of the Sum-of-Divisors Function}}\label{sec:RHExercise}
\logpage{[ 1, 12, 0 ]}
\hyperdef{L}{X7DC7587782057E18}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:RHExercise}
\logpage{[ 1, 12, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{sum-of-divisors function@sum-of-divisors function} \index{harmonic number@harmonic number} Let $\sigma$ denote the sum-of-divisors function. Given a positive integer $n$, let $H(n) := \sum_{k=1}^n 1/k$ be the $n$th harmonic number, and put $B(n) := H(n) + \ln(H(n)) \cdot e^{H(n)}$. 

 Examples are $\sigma(24) = 60$ and $B(24) \approx 61.7575$, as well as $\sigma(60) = 168$ and $B(60) \approx 170.977$. 

 Can you find an integer $n > 1$ such that $\sigma(n)$ is larger than{\nobreakspace}$B(n)$? 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:RHHints}
\logpage{[ 1, 12, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Sigma@\texttt{Sigma}} \index{Float@\texttt{Float}} \index{LOG_FLOAT@\texttt{LOG{\textunderscore}FLOAT}} \index{EXP_FLOAT@\texttt{EXP{\textunderscore}FLOAT}} In \textsf{GAP}, $\sigma(n)$ can be computed by \texttt{Sigma(\mbox{\texttt{\mdseries\slshape n}})}. Use the operation \texttt{Float} to convert integers and rationals to floating point numbers, and use the
functions \texttt{LOG{\textunderscore}FLOAT} and \texttt{EXP{\textunderscore}FLOAT} to compute logarithms and to evaluate the exponential function, respectively.
Be prepared that finding an integer $n > 1$ such that $\sigma(n)$ is larger than{\nobreakspace}$B(n)$ is not easy. 

 For a solution, see Section{\nobreakspace}\ref{sec:RHSolution}. }

 }

  
\section{\textcolor{Chapter }{Pell's Equation}}\label{sec:PellExercise}
\logpage{[ 1, 13, 0 ]}
\hyperdef{L}{X846DB3D77F820871}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:PellExercise}
\logpage{[ 1, 13, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{Pell's equation@Pell's equation} \index{Pell's equation@Pell's equation!fundamental solution} \href{http://en.wikipedia.org/wiki/Pell%27s_equation } {Pell's equation} is any Diophantine equation of the form $x^2 - ny^2 = 1$, where $n$ is a nonsquare integer. 

 Write a \textsf{GAP} function which takes an argument $n$ and returns the smallest solution of the equation $x^2 - ny^2 = 1$ in positive integers! 

 This solution is called the \emph{fundamental solution}. Your function should return for example the answer for $n = 421$ very quickly. 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:PellHints}
\logpage{[ 1, 13, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{ContinuedFractionExpansionOfRoot@\texttt{ContinuedFractionExpansionOfRoot}} \index{ContinuedFractionApproximationOfRoot@\texttt{ContinuedFractionApproximationOfRoot}} Useful functions in this context are \texttt{ContinuedFractionExpansionOfRoot} and \texttt{ContinuedFractionApproximationOfRoot}. 

 For a solution, see Section{\nobreakspace}\ref{sec:PellSolution}. }

 }

  
\section{\textcolor{Chapter }{Automorphism Groups of Odd Order}}\label{sec:AutomorphismGroupOfOddOrderExercise}
\logpage{[ 1, 14, 0 ]}
\hyperdef{L}{X83DD0C2C867A1DF0}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:AutomorphismGroupOfOddOrderExercise}
\logpage{[ 1, 14, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{group@group!automorphism group} Obviously, the automorphism groups of both the trivial group and the cyclic
group of order{\nobreakspace}2 are trivial, and have therefore odd order. Find
the smallest group of order greater than{\nobreakspace}2 whose automorphism
group has odd order! 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:AutomorphismGroupOfOddOrderHints}
\logpage{[ 1, 14, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Small Groups Library@Small Groups Library} \index{AllGroups@\texttt{AllGroups}} \index{AutomorphismGroup@\texttt{AutomorphismGroup}} First try to exclude the groups of even order by means of theory. Then run a \emph{brute-force} search over the Small Groups Library{\nobreakspace}\cite{SmallGroups}. Useful functions / operations in this context are \texttt{AllGroups} and \texttt{AutomorphismGroup}. 

 For a solution, see Section{\nobreakspace}\ref{sec:AutomorphismGroupOfOddOrderSolution}. }

 }

  
\section{\textcolor{Chapter }{Composite Sums}}\label{sec:CompositeSumsExercise}
\logpage{[ 1, 15, 0 ]}
\hyperdef{L}{X7955A612871B3AAF}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:CompositeSumsExercise}
\logpage{[ 1, 15, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  Find an odd positive integer $n$ such that $n+2^k$ is composite for any positive integer{\nobreakspace}$k$! -- Can you find the least possible such{\nobreakspace}$n$? 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:CompositeSumsHints}
\logpage{[ 1, 15, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{OrderMod@\texttt{OrderMod}} \index{ResClasses package@ResClasses package} \index{ResidueClass@\texttt{ResidueClass}} First perform a \emph{brute-force} search to find candidates. Then try to verify whether these candidates indeed
have the desired property. A useful function in this context is \texttt{OrderMod}. In addition, it may be worth to have a look at the \textsf{ResClasses} package{\nobreakspace}\cite{ResClasses}, and there in particular at the function \texttt{ResidueClass}. Finding a good candidate for the least possible number with the given
property is reasonably easy, but the verification that it is indeed the
smallest one is computationally difficult. 

 For a solution, see Section{\nobreakspace}\ref{sec:CompositeSumsSolution}. }

 }

  
\section{\textcolor{Chapter }{Rational Points on the Unit Sphere}}\label{sec:RationalPointsExercise}
\logpage{[ 1, 16, 0 ]}
\hyperdef{L}{X84DD47D37DD483E4}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:RationalPointsExercise}
\logpage{[ 1, 16, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{unit sphere@unit sphere!rational points} \index{rational points@rational points!on the unit sphere} Write a \textsf{GAP} function which computes all rational points on the unit sphere $x^2+y^2+z^2=1$ which correspond to solutions of the diophantine equation $a^2+b^2+c^2=d^2$ with $a$, $b$ and{\nobreakspace}$c$ not exceeding a given bound. Further, your function should draw a picture
showing the projection of one octant of the sphere to the $x$-$y$-plane, where the rational points are marked by black pixels. 

 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:RationalPointsHints}
\logpage{[ 1, 16, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Arrangements@\texttt{Arrangements}} \index{NullMat@\texttt{NullMat}} \index{RCWA package@RCWA package} \index{SaveAsBitmapPicture@\texttt{SaveAsBitmapPicture}} Just write a nested loop to determine the solutions. Note that the variables
can be permuted, thus you can assume $a \geq b \geq c$ and generate the solutions not satisfying this inequality by permuting $a$, $b$ and{\nobreakspace}$c$. This saves almost 5/6 of the time. Maybe a useful function in this context
is \texttt{Arrangements}. Create an empty grid over GF(2) by the function \texttt{NullMat}, invert it (i.e. replace zeros by ones) and mark the solutions by zeros
there. Finally, the \textsf{RCWA} package{\nobreakspace}\cite{RCWA} provides a function \texttt{SaveAsBitmapPicture}, which can be used to write the picture to a file. 

 For a solution, see Section{\nobreakspace}\ref{sec:RationalPointsSolution}. }

 }

  
\section{\textcolor{Chapter }{Aliquot Sequences}}\label{sec:AliquotExercise}
\logpage{[ 1, 17, 0 ]}
\hyperdef{L}{X85C3564D79898089}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:AliquotExercise}
\logpage{[ 1, 17, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{Aliquot sequence@Aliquot sequence} \index{sum-of-divisors function@sum-of-divisors function} Given a positive integer $n$, the \emph{Aliquot sequence} $n = a_1, a_2, a_3, a_4, \dots$ starting at $n$ is defined by $a_{i+1} = \sigma(a_i) - a_i$, where $\sigma$ denotes the sum-of-divisors function. We say that the Aliquot sequence
starting at{\nobreakspace}$n$ \emph{stops} if there is an index $i$ such that $a_i = 1$, and we say that it \emph{runs into a cycle} if there are distinct indices $i$ and{\nobreakspace}$j$ such that $a_i = a_j$. 

 Find out whether all Aliquot sequences starting at integers $n < 100$ either stop or run into cycles! -- Can you do the same for all Aliquot
sequences starting at integers $n < 200$ or $n < 300$? Do you see algorithmic problems, and of which kind are they? }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:AliquotHints}
\logpage{[ 1, 17, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{Sigma@\texttt{Sigma}} \index{FactorsInt@\texttt{FactorsInt}} \index{FactInt package@FactInt package} \index{SUM_FLAGS@\texttt{SUM{\textunderscore}FLAGS}} \index{method installation@method installation} \index{changing the GAP Library@changing the GAP Library} \index{rebuilding completion files@rebuilding completion files} \index{CreateCompletionFiles@\texttt{CreateCompletionFiles}} In \textsf{GAP}, $\sigma(n)$ can be computed by \texttt{Sigma(\mbox{\texttt{\mdseries\slshape n}})}. Computing $\sigma(n)$ requires factoring $n$. For this, the \textsf{GAP} Library method for the operation \texttt{Sigma} calls the \textsf{GAP} Library function \texttt{FactorsInt} directly. This works for small $n$, but for larger $n$, \texttt{FactorsInt} will often give up and raise an error message which suggests to use the \textsf{FactInt} package{\nobreakspace}\cite{FactInt}. If you have loaded \textsf{FactInt}, you may find this strange. However, this has nothing to do with \textsf{FactInt}, as this package does not get a chance to help with factoring. You can make \texttt{Sigma} benefit from \textsf{FactInt} if you fetch the method for \texttt{Sigma} from \texttt{lib/numtheor.gi}, put it into a separate file, replace \texttt{FactorsInt} by \texttt{Factors}, increase the method rank to something like \texttt{SUM{\textunderscore}FLAGS} and read this file into \textsf{GAP}. Alternatively you can make the change directly in the \textsf{GAP} Library. Then you do not need to increase the method rank, but (as after every
Library change) you need to rebuild the completion files. For this, start \textsf{GAP} with option -N and enter \texttt{CreateCompletionFiles();}. 

 For a solution, see Section{\nobreakspace}\ref{sec:AliquotSolution}. }

 }

  
\section{\textcolor{Chapter }{The Q Sequence}}\label{sec:QExercise}
\logpage{[ 1, 18, 0 ]}
\hyperdef{L}{X7AC6CF047AF04240}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:QExercise}
\logpage{[ 1, 18, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{Q sequence@Q sequence} \index{function@function!recursive} Hofstadter's \href{ http://mathworld.wolfram.com/HofstadtersQ-Sequence.html} {Q sequence} is defined by $Q_1 = Q_2 = 1$ and $Q_{n} = Q_{n-Q_{n-1}} + Q_{n-Q_{n-2}}$ for $n > 2$. 
\begin{description}
\item[{a)}]  Write a \textsf{GAP} function which takes an integer argument{\nobreakspace}$l$ and computes the first $l$ terms of the Q{\nobreakspace}sequence. 
\item[{b)}]  Write a \textsf{GAP} function which plots the graph of the Q{\nobreakspace}sequence. 
\end{description}
 }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:QHints}
\logpage{[ 1, 18, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{NullMat@\texttt{NullMat}} \index{SaveAsBitmapPicture@\texttt{SaveAsBitmapPicture}} \index{RCWA package@RCWA package} 
\begin{description}
\item[{ad a)}]  The Q sequence is defined recursively. Ask yourself the question why a
recursive implementation is not a particularly good idea in this case, anyway. 
\item[{ad b)}]  Use the function \texttt{NullMat} to create a zero matrix over the field with two elements, turn the zeros into
ones if you prefer a black graph on a white background to a white graph on a
black background, and use this matrix as a grid to draw the graph. The \textsf{RCWA} package{\nobreakspace}\cite{RCWA} provides a function \texttt{SaveAsBitmapPicture}, which can be used to produce a picture file from the matrix. 
\end{description}
 For a solution, see Section{\nobreakspace}\ref{sec:QSolution}. }

 }

  
\section{\textcolor{Chapter }{A Quickly Growing Function}}\label{sec:QuicklyGrowingFunctionExercise}
\logpage{[ 1, 19, 0 ]}
\hyperdef{L}{X83C05648831160FB}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:QuicklyGrowingFunctionExercise}
\logpage{[ 1, 19, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{computable function@} \index{function@function!computable} \index{function@function!quickly growing} \index{function@function!recursive} Have a look at the following function, which takes as arguments three
nonnegative integers and which returns a positive integer: \pagebreak[4] 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  f := function ( i, j, k )
    if i = 0 then
      if   j = 0
      then if k = 0 then return 2; else return 2^f(i,j,k-1); fi;
      else return f(i,j-1,f(i,j-1,k)); fi;
    else
      return f(i-1,f(i-1,j,k),f(i-1,j,k));
    fi;
  end;
  
\end{Verbatim}
 Try to evaluate \texttt{f} for small values of \texttt{i}, \texttt{j} and{\nobreakspace}\texttt{k}! -- How far can you get? Can you evaluate \texttt{f(1,1,1)} or \texttt{f(2,2,2)}, or can you perhaps write down these values as non-recursive expressions? 

 The function \texttt{f} is still a computable function -- recall however that there are functions
which grow faster than \emph{any} computable function! }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:QuicklyGrowingFunctionHints}
\logpage{[ 1, 19, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  Some values this function takes: \texttt{f(0,0,0)} is{\nobreakspace}2, \texttt{f(0,0,1)} is{\nobreakspace}4, \texttt{f(0,0,2)} and \texttt{f(0,1,0)} are both{\nobreakspace}16, \texttt{f(0,0,3)} is{\nobreakspace}65536, \texttt{f(0,0,4)} and \texttt{f(0,1,1)} are both{\nobreakspace}$2^{65536}$, \texttt{f(0,0,5)} is{\nobreakspace}$2^{2^{65536}}$, and already \texttt{f(1,1,1)} is basically too large to be written down in a non-recursive way. The exercise
asks just for some experimentation -- thus there is no solution given. }

 }

  
\section{\textcolor{Chapter }{The 3n+1 Conjecture}}\label{sec:CollatzConjectureExercise}
\logpage{[ 1, 20, 0 ]}
\hyperdef{L}{X7B58371E853887CC}{}
{
  
\subsection{\textcolor{Chapter }{Exercise}}\label{ssec:CollatzConjectureExercise}
\logpage{[ 1, 20, 1 ]}
\hyperdef{L}{X87183DD885B8DE76}{}
{
  \index{3n+1 conjecture@3n+1 conjecture} \index{Collatz conjecture@Collatz conjecture} \index{Collatz mapping@Collatz mapping} The \emph{$3n+1$ conjecture}, also known as \emph{Collatz conjecture}, asserts that iterated application of the \emph{Collatz mapping}  
\[ T: \ \ \mathbb{Z} \longrightarrow \mathbb{Z}, \ \ \ \ n \ \longmapsto \
\begin{cases} \frac{n}{2} & \text{if} \ \ n \ \ \text{is even}, \\
\frac{3n+1}{2} & \text{if} \ \ n \ \ \text{is odd} \end{cases} \]
    to any given positive integer eventually yields{\nobreakspace}1. This problem
has been posed by Lothar Collatz in the 1930's, and it is still open today. 

 Investigate Collatz' conjecture by means of computation with \textsf{GAP}, and try to find a proof or a counterexample! }

 
\subsection{\textcolor{Chapter }{Hints}}\label{ssec:CollatzConjectureHints}
\logpage{[ 1, 20, 2 ]}
\hyperdef{L}{X8532838B79362B49}{}
{
  \index{RCWA package@RCWA package} \index{3n+1 problem bibliography@3n+1 problem bibliography} \index{Lagarias bibliography@Lagarias bibliography} \index{RcwaMapping@\texttt{RcwaMapping}} \index{SetName@\texttt{SetName}} \index{Display@\texttt{Display}} \index{Trajectory@\texttt{Trajectory}} The $3n+1$ conjecture is generally believed to be true, but if it is false, this may be
for two reasons: firstly, there may be unbounded sequences, and secondly,
there may be sequences which run into cycles not containing{\nobreakspace}1.
Jeffrey C. Lagarias has compiled a comprehensive annotated
bibliography{\nobreakspace}\cite{Lagarias07} on this conjecture. The \textsf{GAP} package \textsf{RCWA}{\nobreakspace}\cite{RCWA} provides a large variety of methods to compute with mappings like the Collatz
mapping. We show just how to enter the Collatz mapping and how to compute the
sequences we are interested in: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> T := RcwaMapping([[1,0,2],[3,1,2]]);
  <rcwa mapping of Z with modulus 2>
  gap> SetName(T,"T");
  gap> Display(T);
  
  Rcwa mapping of Z with modulus 2
  
                n mod 2               |                n^T
  ------------------------------------+------------------------------------
    0                                 | n/2
    1                                 | (3n + 1)/2
  
  gap> Trajectory(T,15,[1]);
  [ 15, 23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2, 1 ]
  gap> Trajectory(T,27,[1]);
  [ 27, 41, 62, 31, 47, 71, 107, 161, 242, 121, 182, 91, 137, 206, 103, 
    155, 233, 350, 175, 263, 395, 593, 890, 445, 668, 334, 167, 251, 377, 
    566, 283, 425, 638, 319, 479, 719, 1079, 1619, 2429, 3644, 1822, 911, 
    1367, 2051, 3077, 4616, 2308, 1154, 577, 866, 433, 650, 325, 488, 244, 
    122, 61, 92, 46, 23, 35, 53, 80, 40, 20, 10, 5, 8, 4, 2, 1 ]
  
\end{Verbatim}
 There is (of course!) no solution given for this exercise. }

 }

  }

       
\chapter{\textcolor{Chapter }{The Solutions}}\label{ch:Solutions}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X85E0DEFD7F681250}{}
{
  
\section{\textcolor{Chapter }{On Commutators and Derived Subgroups (Solution)}}\label{sec:CommutatorSolution}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7F07017C7CD62CFD}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:CommutatorExercise}. 

 \index{CommutatorLength@\texttt{CommutatorLength}} There is a function \texttt{CommutatorLength(\mbox{\texttt{\mdseries\slshape G}})}, which returns the minimal number $n$ such that each element in the derived subgroup of the group \mbox{\texttt{\mdseries\slshape G}} can be written as a product of (at most) $n$ commutators of elements of{\nobreakspace}\mbox{\texttt{\mdseries\slshape G}}. For the groups we are looking for, this function returns a value greater
than{\nobreakspace}1. However, \texttt{CommutatorLength} is reasonably slow and we need to check many groups. Therefore we write an own
little function as follows: \index{CommutatorsFormGroup@\texttt{CommutatorsFormGroup}} \index{Comm@\texttt{Comm}} \index{DerivedSubgroup@\texttt{DerivedSubgroup}} \index{Cartesian@\texttt{Cartesian}} \index{Set@\texttt{Set}} \index{AsList@\texttt{AsList}}\index{@\texttt{}} \index{Length@\texttt{Length}} \index{Size@\texttt{Size}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  CommutatorsFormGroup := G -> Length(Set(Cartesian(AsList(G),AsList(G)),
                                                    t -> Comm(t[1],t[2])))
                             = Size(DerivedSubgroup(G));
  
\end{Verbatim}
 Of course this function uses just a \emph{brute-force} approach, and you might find it worth to look for a better algorithm to check
whether the commutators form a subgroup -- but for our purposes it is
sufficient as it stands. \index{Small Groups Library@Small Groups Library} Now we simply need to loop over the groups stored in the Small Groups
Library{\nobreakspace}\cite{SmallGroups} until we find one for which this function returns \texttt{false}: \index{Print@\texttt{Print}} \index{AllGroups@\texttt{AllGroups}} \index{First@\texttt{First}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> n := 0;;
  gap> repeat
  >      n := n + 1; Print("n = ",n,"\n");
  >      G := First(AllGroups(n),G->not CommutatorsFormGroup(G));
  >    until G <> fail;
  
\end{Verbatim}
 Certainly we could think about which groups we can already exclude by means of
theory, but for our purposes here this turns out to be not necessary. We
obtain the following: \index{IdGroup@\texttt{IdGroup}} \index{StructureDescription@\texttt{StructureDescription}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> IdGroup(G);
  [ 96, 3 ]
  gap> StructureDescription(G);
  "((C4 x C2) : C4) : C3"
  
\end{Verbatim}
 The possible orders $\leq 256$ of groups which have the desired property are 96, 128, 144, 162, 168, 192,
216, 240, 256. A low-degree permutation group with our property is 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> G := Group((1,3)(2,4),(5,7)(6,8),(9,11)(10,12),(13,15)(14,16),
  >               (1,3)(5,7)(9,11),(1,2)(3,4)(13,15),(5,6)(7,8)(13,14)(15,16),
  >               (9,10)(11,12));;
  gap> CommutatorLength(G);
  2
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{On Outer Automorphisms Fixing Conjugacy Classes (Solution)}}\label{sec:OuterAutomorphismsSolution}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7CC64D5787EF16B2}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:OuterAutomorphismsExercise}. 

 We perform a \emph{brute-force} search. For this we write straightforward code that uses a ``problem-oriented'' approach: \index{Print@\texttt{Print}} \index{First@\texttt{First}} \index{IsAbelian@\texttt{IsAbelian}} \index{ForAny@\texttt{ForAny}} \index{AsList@\texttt{AsList}} \index{AutomorphismGroup@\texttt{AutomorphismGroup}} \index{ForAll@\texttt{ForAll}} \index{IsConjugate@\texttt{IsConjugate}} \index{Image@\texttt{Image}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> n := 1;;
  gap> repeat
  >      Print(n,"\n");
  >      G := First(AllGroups(n),
  >                 G -> not IsAbelian(G)
  >                  and ForAny(AsList(AutomorphismGroup(G)),
  >                             aut -> not IsInnerAutomorphism(aut)
  >                                and ForAll(AsList(G),
  >                                           g->IsConjugate(G,g,
  >                                                          Image(aut,g)))));
  >      n := n + 1;
  >    until G <> fail;
  
\end{Verbatim}
 This loop runs a couple of minutes. This is likely less than the additional
time it would take to exclude many groups from the search by means of theory
or to write code which tests given groups faster. Nevertheless you might be
interested in looking at this question from a theoretical point of view and in
trying to find out more about the structure of groups which permit non-inner
conjugacy class fixing automorphisms. 

 We obtain the following: \index{IdGroup@\texttt{IdGroup}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> G;
  <pc group of size 32 with 5 generators>
  gap> IdGroup(G);
  [ 32, 43 ]
  
\end{Verbatim}
 We would like to find a nice faithful permutation representation
of{\nobreakspace}$G$ which permits us to see how our automorphism looks like. For this purpose we
look for suitable subgroups, and let $G$ act from the right on right cosets. Since $32 > 4!$, there is no hope to find a faithful permutation representation of
degree{\nobreakspace}4. However we can find one of degree{\nobreakspace}8: \index{Filtered@\texttt{Filtered}} \index{List@\texttt{List}} \index{ConjugacyClassesSubgroups@\texttt{ConjugacyClassesSubgroups}} \index{Representative@\texttt{Representative}} \index{Size@\texttt{Size}} \index{Set@\texttt{Set}} \index{Action@\texttt{Action}} \index{RightCosets@\texttt{RightCosets}} \index{OnRight@\texttt{OnRight}} \index{Group@\texttt{Group}} \index{ConjugacyClasses@\texttt{ConjugacyClasses}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> S4 := Filtered(List(ConjugacyClassesSubgroups(G),Representative),
  >                   S->Size(S)=4);;
  gap> permreps := Set(Filtered(List(S4,S->Action(G,RightCosets(G,S),OnRight)),
  >                             H->Size(H)=32));
  [ Group([ (1,2)(3,8)(4,6)(5,7), (2,8)(3,7)(5,6), (2,6)(5,8),
        (1,3,4,7)(2,5,6,8), (1,4)(2,6)(3,7)(5,8) ]) ]
  gap> G := permreps[1];;
  gap> ConjugacyClasses(G);
  [ ()^G, (2,5)(3,7)(6,8)^G, (2,6)(5,8)^G, (2,8)(3,7)(5,6)^G, 
    (1,2)(3,8)(4,6)(5,7)^G, (1,2,3,5,4,6,7,8)^G, (1,2,4,6)(3,8,7,5)^G, 
    (1,2,7,8,4,6,3,5)^G, (1,3,4,7)(2,5,6,8)^G, (1,3,4,7)(2,8,6,5)^G, 
    (1,4)(2,6)(3,7)(5,8)^G ]
  gap> G := G^(4,5);; # we want (1,2,3,4,5,6,7,8) in G
  gap> List(ConjugacyClasses(G),Representative); # pick nicer generators ...
  [ (), (2,4)(3,7)(6,8), (2,6)(4,8), (2,8)(3,7)(4,6), (1,2)(3,8)(4,7)(5,6),
    (1,2,3,4,5,6,7,8), (1,2,5,6)(3,8,7,4), (1,2,7,8,5,6,3,4),
    (1,3,5,7)(2,4,6,8), (1,3,5,7)(2,8,6,4), (1,5)(2,6)(3,7)(4,8) ]
  gap> G = Group((1,2,3,4,5,6,7,8),(2,4)(3,7)(6,8),(2,8)(3,7)(4,6));
  true
  
\end{Verbatim}
 Now let's have a look at our automorphism: \index{AutomorphismGroup@\texttt{AutomorphismGroup}} \index{IsInnerAutomorphism@\texttt{IsInnerAutomorphism}} \index{ForAll@\texttt{ForAll}} \index{IsConjugate@\texttt{IsConjugate}} \index{Image@\texttt{Image}} \index{Length@\texttt{Length}} \index{GroupHomomorphismByImages@\texttt{GroupHomomorphismByImages}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> a := (1,2,3,4,5,6,7,8);; b := (2,4)(3,7)(6,8);; c := (2,8)(3,7)(4,6);;
  gap> G := Group(a,b,c);; # the nice representation determined above
  gap> A := AutomorphismGroup(G);
  <group of size 64 with 6 generators>
  gap> auts := Filtered(AsList(A),
  >                     aut ->  not IsInnerAutomorphism(aut)
  >                         and ForAll(AsList(G),
  >                                    g -> IsConjugate(G,g,Image(aut,g))));;
  gap> Length(auts); # there are 16 suitable aut's -- find the nicest of them:
  16
  gap> auts := Filtered(auts,aut->Image(aut,a)=a);; # those fixing a
  gap> Length(auts);
  4
  gap> auts := Filtered(auts,aut->Image(aut,b)=b);; # those fixing b as well
  gap> Length(auts);
  1
  gap> aut := auts[1];; # this one fixes a and b, and moves the generator c
  gap> c; Image(aut,c);
  (2,8)(3,7)(4,6)
  (1,5)(2,4)(6,8)
  gap> c/Image(aut,c);
  (1,5)(2,6)(3,7)(4,8)
  gap> last = a^4; # our automorphism multiplies c by a^4
  true
  gap> aut = GroupHomomorphismByImages(G,G,[a,b,c],[a,b,a^4*c]); # check
  true
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Drawing the Ulam Spiral (Solution)}}\label{sec:UlamSpiralSolution}
\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X84E2293F7956B8D0}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:UlamSpiralExercise}. 

 We can write the function as follows: \index{UlamSpiral@\texttt{UlamSpiral}} \index{Filtered@\texttt{Filtered}} \index{NullMat@\texttt{NullMat}} \index{GF@\texttt{GF}} \index{IsPrimeInt@\texttt{IsPrimeInt}} \index{Zero@\texttt{Zero}} \index{One@\texttt{One}} \index{SaveAsBitmapPicture@\texttt{SaveAsBitmapPicture}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  UlamSpiral := function ( size, filename )
  
    local  spiral, smallprimes, n, p, r,
           middle, edgelength, edgepos, direction, i, j, zero, one;
  
    smallprimes := Filtered([2..size],IsPrimeInt);
    spiral      := NullMat(size,size,GF(2));
  
    if size mod 2 = 0 then middle := [size/2,size/2];
                      else middle := [(size + 1)/2,(size + 1)/2]; fi;
  
    zero := Zero(GF(2)); one := One(GF(2));
  
    spiral[middle[1]][middle[2]] := one;
  
    for p in smallprimes do
      i := middle[1]; j := middle[2];
      edgelength := 2; edgepos := 1; direction := 0; r := 1;
      for n in [2..size^2] do
        if   direction = 0 then j := j + 1;
        elif direction = 1 then i := i + 1;
        elif direction = 2 then j := j - 1;
        elif direction = 3 then i := i - 1; fi;
        r       := r + 1;
        edgepos := edgepos + 1;
        if r = p then
          if n > p then spiral[i][j] := one; fi;
          r := 0;
        fi;
        if edgepos = edgelength then
          direction := (direction + 1) mod 4;
          if direction in [0,2] then edgelength := edgelength + 1; fi;
          edgepos := 1;
        fi;
      od;
    od;
  
    SaveAsBitmapPicture(spiral,filename);
  end;
  
\end{Verbatim}
 \index{Sieve of Eratosthenes@Sieve of Eratosthenes} In this solution, we do a \emph{Sieve of Eratosthenes} inside the spiral. This saves some memory, but doing the sieving before
drawing the spiral would be faster. }

  
\section{\textcolor{Chapter }{ Automorphism Group of the Smallest Projective Plane (Solution) }}\label{sec:ProjectivePlaneSolution}
\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X867990408293E194}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:ProjectivePlaneExercise}. 

 We determine the requested automorphism group as a subgroup of the symmetric
group of degree{\nobreakspace}7 as follows: \index{SubgroupProperty@\texttt{SubgroupProperty}} \index{SymmetricGroup@\texttt{SymmetricGroup}} \index{Set@\texttt{Set}} \index{StructureDescription@\texttt{StructureDescription}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> p7 := [[1,2,3],[1,4,7],[1,5,6],[2,4,6],[2,5,7],[3,4,5],[3,6,7]];;
  gap> G := SubgroupProperty(SymmetricGroup(7),x->Set(p7,g->Set(g,p->p^x))=p7);
  Group([ (2,6)(3,5), (2,5)(3,6), (2,5,7)(3,6,4), (1,2,5,6,4,3,7) ])
  gap> StructureDescription(G);
  "PSL(3,2)"
  
\end{Verbatim}
 The group $G$ is isomorphic to PSL(3,2) since the smallest projective plane is the one over
the field GF(2) with 2 elements, and since the group PSL($n$,$q$) is defined as the automorphism group of the projective space of affine
dimension{\nobreakspace}$n$ (i.e. of projective dimension $n-1$) over{\nobreakspace}GF($q$). Our approach works since all groups we are dealing with are small, thus \texttt{SubgroupProperty} is practical. }

  
\section{\textcolor{Chapter }{Installing a Missing Method (Solution)}}\label{sec:InstallingMethodsSolution}
\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X822F4BC78503EAA6}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:InstallingMethodsExercise}. 

 We can implement the needed method as follows: \index{InstallMethod@\texttt{InstallMethod}} \index{Centre@\texttt{Centre}} \index{IsSimpleGroup@\texttt{IsSimpleGroup}} \index{IsAbelian@\texttt{IsAbelian}} \index{TrivialSubgroup@\texttt{TrivialSubgroup}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  InstallMethod( Centre, "for simple groups", true, [ IsSimpleGroup ], 50,
                 function( G )
                   if   IsAbelian( G ) then return G;
                   else return TrivialSubgroup( G ); fi;
                 end );
  
\end{Verbatim}
 \index{method selection@method selection} \index{method rank@method rank} We set the rank to 50 to make \textsf{GAP}'s method selection choose this method in cases where multiple methods are
applicable. }

  
\section{\textcolor{Chapter }{Finding Good abc Triples (Solution)}}\label{sec:abcTriplesSolution}
\logpage{[ 2, 6, 0 ]}
\hyperdef{L}{X7AD80CEF7E2B99F8}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:abcTriplesExercise}. 

 We can write the function as follows: \index{abcTriplesByRadical@\texttt{abcTriplesByRadical}} \index{Union@\texttt{Union}} \index{Factors@\texttt{Factors}} \index{Filtered@\texttt{Filtered}} \index{Gcd@\texttt{Gcd}} \index{Product@\texttt{Product}} \index{Set@\texttt{Set}} \index{LOG_FLOAT@\texttt{LOG{\textunderscore}FLOAT}} \index{Float@\texttt{Float}} \index{Add@\texttt{Add}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  abcTriplesByRadical := function ( radical, bound )
  
    local  triples, values, values_last, factors, a, b, c, rad_abc, ratio;
  
    factors := Union(Factors(radical),[1]);
    values  := [1];
    repeat
      values_last := values;
      values := Filtered(Union(List(factors,p->values*p)),n->n<bound);
    until values = values_last;
    triples := [];
    for a in values do
      for b in values do
        if b >= a then break; fi;
        if a + b in values and Gcd(a,b) = 1 then
          c       := a + b;
          rad_abc := Product(Set(Factors(a*b*c)));
          ratio   := LOG_FLOAT(Float(c))/LOG_FLOAT(Float(rad_abc));
          if ratio > 7/5 then Add(triples,[a,b,c]); fi;
        fi;
      od;
    od;
    return triples;
  end;
  
\end{Verbatim}
 In the first loop we determine all positive integers less than \mbox{\texttt{\mdseries\slshape bound}} all of whose prime factors divide \mbox{\texttt{\mdseries\slshape radical}}. For this we neither perform a loop over all integers in the range from 1 to \mbox{\texttt{\mdseries\slshape bound}} nor we factor integers. In the nested loop afterwards we determine the abc
triples by a \emph{brute-force} search. 

 We obtain for example the following: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> abcTriplesByRadical( 2 * 3 * 5 * 7, 10000 );
  [ [ 125, 3, 128 ], [ 2400, 1, 2401 ], [ 4374, 1, 4375 ] ]
  gap> abcTriplesByRadical( 2 * 3 * 23 * 109, 10^7 );
  [ [ 6436341, 2, 6436343 ] ]
  
\end{Verbatim}
 The latter is currently the best known abc triple. Its ratio is $\ln(c)/\ln({\rm rad}(abc)) \approx 1.62991$. 

 A more elaborate method to search for good abc triples is described
in{\nobreakspace}\cite{Dokchitser03}. }

  
\section{\textcolor{Chapter }{Automorphism Groups of Finite Graphs (Solution)}}\label{sec:GraphsSolution}
\logpage{[ 2, 7, 0 ]}
\hyperdef{L}{X8783A105786126E6}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:GraphsExercise}. 

 
\begin{description}
\item[{ad a)}]  We let the symmetric group of the set of vertices act on the set of all graphs
with the given number of vertices. The orbits under that action are the
isomorphism classes. As said in the hints, we obtain the set of all graphs
with \mbox{\texttt{\mdseries\slshape n}} vertices by \texttt{Combinations(Combinations([1..\mbox{\texttt{\mdseries\slshape n}}],2))}. We can write a \textsf{GAP} function which takes an argument{\nobreakspace}\mbox{\texttt{\mdseries\slshape n}} and which returns a set of representatives for the isomorphism classes of
graphs with \mbox{\texttt{\mdseries\slshape n}} vertices: \index{AllGraphs@\texttt{AllGraphs}} \index{List@\texttt{List}} \index{Orbits@\texttt{Orbits}} \index{SymmetricGroup@\texttt{SymmetricGroup}} \index{Combinations@\texttt{Combinations}} \index{Set@\texttt{Set}} \index{OnSets@\texttt{OnSets}} \index{Representative@\texttt{Representative}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  AllGraphs := n -> List(Orbits(SymmetricGroup(n),
                                Combinations(Combinations([1..n],2)),
                                function(Gamma,g)
                                  return Set(Gamma,k->OnSets(k,g));
                                end),
                         Representative);
  
\end{Verbatim}
 For \mbox{\texttt{\mdseries\slshape n}} = 1, 2, 3, 4, 5 and 6, we obtain 1, 2, 4, 11, 34 and 156 graphs, respectively.
We observe a significant increase in runtime requirements between \mbox{\texttt{\mdseries\slshape n}}{\nobreakspace}={\nobreakspace}5 and \mbox{\texttt{\mdseries\slshape n}}{\nobreakspace}={\nobreakspace}6. 
\item[{ad b)}]  We can write the \textsf{GAP} function as follows: \index{GraphAutomorphismGroup@\texttt{GraphAutomorphismGroup}} \index{SubgroupProperty@\texttt{SubgroupProperty}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  GraphAutomorphismGroup := function( Gamma, n )
    return SubgroupProperty(SymmetricGroup(n),
                            g -> Set(Gamma,k->OnSets(k,g)) = Set(Gamma));
  end;
  
\end{Verbatim}
 Of course we could put much more effort into writing such a function in order
to obtain a satisfactory performance also for reasonably large graphs -- but
for our purposes the given one is already good enough. 
\item[{ad c)}]  We write a \textsf{GAP} function which determines all transitive permutation groups of given
degree{\nobreakspace}\mbox{\texttt{\mdseries\slshape n}} which occur as automorphism groups of graphs: \index{TransitiveGraphAutomorphismGroups@\texttt{TransitiveGraphAutomorphismGroups}} \index{AllGraphs@\texttt{AllGraphs}} \index{Filtered@\texttt{Filtered}} \index{IsTransitive@\texttt{IsTransitive}} \index{AllTransitiveGroups@\texttt{AllTransitiveGroups}} \index{NrMovedPoints@\texttt{NrMovedPoints}} \index{TransitiveIdentification@\texttt{TransitiveIdentification}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  TransitiveGraphAutomorphismGroups := function( n )
  
    local  graphs, groups; 
  
    graphs := AllGraphs(n);
    groups := Filtered(List(graphs,Gamma->GraphAutomorphismGroup(Gamma,n)),
                       G -> IsTransitive(G,[1..n]));
    return AllTransitiveGroups(NrMovedPoints,n)
             {Set(groups,TransitiveIdentification)};
  end;
  
\end{Verbatim}
 As often, it is possible to abridge this function without performance loss: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  TransitiveGraphAutomorphismGroups :=
    n -> AllTransitiveGroups(NrMovedPoints,n)
           {Set(Filtered(List(AllGraphs(n),
                              Gamma->GraphAutomorphismGroup(Gamma,n)),
                         G -> IsTransitive(G,[1..n])),
                TransitiveIdentification)};
  
\end{Verbatim}
 In general one needs to be a bit careful to avoid computing the same things
again and again, to avoid filling up the memory with junk objects and to
recognize other possible sources of performance problems when one shrinks
functions in such a way. 

 We obtain the following: \pagebreak[4] \index{GeneratorsOfGroup@\texttt{GeneratorsOfGroup}} \index{StructureDescription@\texttt{StructureDescription}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> TransitiveGraphAutomorphismGroups(3);
  [ S3 ]
  gap> TransitiveGraphAutomorphismGroups(4);
  [ D(4), S4 ]
  gap> TransitiveGraphAutomorphismGroups(5);
  [ D(5) = 5:2, S5 ]
  gap> TransitiveGraphAutomorphismGroups(6);
  [ D(6) = S(3)[x]2, 2S_4(6) = [2^3]S(3) = 2 wr S(3), 
    F_36(6):2 = [S(3)^2]2 = S(3) wr 2, S6 ]
  gap> List(last, Size);
  [ 12, 48, 72, 720 ]
  gap> List(last2, GeneratorsOfGroup);
  [ [ (1,2,3,4,5,6), (1,4)(2,3)(5,6) ], [ (3,6), (1,3,5)(2,4,6), (1,5)(2,4) ], 
    [ (2,4,6), (2,4), (1,4)(2,5)(3,6) ], [ (1,2,3,4,5,6), (1,2) ] ]
  gap> List(last3, StructureDescription);
  [ "D12", "C2 x S4", "(S3 x S3) : C2", "S6" ]
  
\end{Verbatim}
 Now we determine the corresponding graphs. Since the automorphism group of a
graph is invariant under taking the complement, we can restrict our
considerations to graphs with at most $[\frac{1}{2} \cdot \binom62] = 7$ edges -- complements of solutions are then solutions as well. \index{HomogeneousGraphs@\texttt{HomogeneousGraphs}} \index{Length@\texttt{Length}} \index{Size@\texttt{Size}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> HomogeneousGraphs :=
  >      Filtered(AllGraphs(6),
  >               Gamma -> Length(Gamma) <= 7 and
  >                        IsTransitive(GraphAutomorphismGroup(Gamma,6),
  >                                     [1..6]));
  [ [  ], [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 4, 5 ], [ 4, 6 ], [ 5, 6 ] ], 
    [ [ 1, 2 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], [ 4, 6 ], [ 5, 6 ] ], 
    [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ] ]
  gap> List(HomogeneousGraphs, Gamma -> Size(GraphAutomorphismGroup(Gamma, 6)));
  [ 720, 72, 12, 48 ]
  
\end{Verbatim}
 Thus for the dihedral group of order{\nobreakspace}12 we get the hexagon, for ${\rm C}_2 \wr {\rm S}_3$ we get the graph consisting of 3 disconnected edges, for ${\rm S}_3 \wr {\rm C}_2$ we get the graph consisting of 2 separate triangles, and for ${\rm S}_6$ we get the empty graph. 
\end{description}
 \index{GRAPE package@GRAPE package} There is a \textsf{GAP} package GRAPE{\nobreakspace}\cite{GRAPE}, which is dedicated to computations with graphs. }

  
\section{\textcolor{Chapter }{Enumerating Paths (Solution)}}\label{sec:EnumeratingPathsSolution}
\logpage{[ 2, 8, 0 ]}
\hyperdef{L}{X7CF4B322817F814A}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:EnumeratingPathsExercise}. 

 
\begin{description}
\item[{ad a)}]  We can write the following function to determine a suitable $x \in \mathbb{Z}^{24 \times 24}$: \pagebreak[4] \index{TranspositionMatrixSn@\texttt{TranspositionMatrixSn}} \index{AsList@\texttt{AsList}} \index{SymmetricGroup@\texttt{SymmetricGroup}} \index{List@\texttt{List}} \index{Combinations@\texttt{Combinations}} \index{ListWithIdenticalEntries@\texttt{ListWithIdenticalEntries}} \index{Factorial@\texttt{Factorial}} \index{Position@\texttt{Position}} \index{Add@\texttt{Add}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  TranspositionMatrixSn := function ( n )
  
    local  x, Sn, transpositions, line, g, t;
  
    Sn := AsList(SymmetricGroup(n));
    transpositions := List(Combinations([1..n],2),t->(t[1],t[2]));
    x := [];
    for g in Sn do
      line := ListWithIdenticalEntries(Factorial(n), 0);
      for t in transpositions do line[Position(Sn,g*t)] := 1; od;
      Add(x, line);
    od;
    return x;
  end;
  
\end{Verbatim}
 The lines and columns of the matrix correspond to the elements $1 = g_1, \dots, g_{24}$ of{\nobreakspace}${\rm S}_4$, and it is  
\[ x_{ij} \ = \ \begin{cases} 1 & \text{if there is a transposition} \ t \
\text{such that} \ g_i \cdot t = g_j, \\ 0 & \text{otherwise}. \end{cases} \]
   It is easy to check that $(x^n)_{ij}$ is the number of ways to take $g_i$ to $g_j$ by multiplication from the right by $n$ transpositions. Therefore we get the solution as follows: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> x := TranspositionMatrixSn(4);; y := x^100;; y[1][1];
  54443218625005908841390855596504818378095309207030310578760502581913955860480
  
\end{Verbatim}
 
\item[{ad b)}]  We can write the following function to determine a suitable $x \in \mathbb{Z}^{64 \times 64}$: \index{HorsesMatrix@\texttt{HorsesMatrix}} \index{NullMat@\texttt{NullMat}} \index{Intersection@\texttt{Intersection}} \index{Cartesian@\texttt{Cartesian}} \index{Add@\texttt{Add}} \index{Flat@\texttt{Flat}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  HorsesMatrix := function ( )
  
    local  x, board, moves, m, i, j;
  
    x := [];
    for i in [1..8] do
      for j in [1..8] do
        board := NullMat(8,8);
        moves := [[i-2,j-1], [i-2,j+1], [i-1,j-2], [i-1,j+2],
                  [i+2,j+1], [i+2,j-1], [i+1,j+2], [i+1,j-2]];
        for m in Intersection(moves,Cartesian([1..8],[1..8]))
        do board[m[1]][m[2]] := 1; od;
        Add(x,Flat(board));
      od;
    od;
    return x;
  end;
  
\end{Verbatim}
 We proceed analogous to Part{\nobreakspace}a). Here the lines and columns of
the correspond to the 64 squares of the chess board, and the matrix is filled
with zeros and ones in such a way that $x_{ij} = 1$ if and only if the horse can jump from square{\nobreakspace}$i$ to square{\nobreakspace}$j$ in one move. Similar as above, we get the solution as follows: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> x := HorsesMatrix();;
  gap> y := x^100;; y[1][64];
  2593244602149234588139078903115618952040745476069710377506002611030781169300
  
\end{Verbatim}
 
\end{description}
 }

  
\section{\textcolor{Chapter }{Wieferich Primes (Solution)}}\label{sec:WieferichPrimesSolution}
\logpage{[ 2, 9, 0 ]}
\hyperdef{L}{X80F2A2B17E44B79F}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:WieferichPrimesExercise}. 

 We can write the function as follows: \index{IsWieferichPrimeInt@\texttt{IsWieferichPrimeInt}} \index{IsPrimeInt@\texttt{IsPrimeInt}} \index{PowerModInt@\texttt{PowerModInt}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  IsWieferichPrimeInt := p -> IsPrimeInt(p) and PowerModInt(2,p-1,p^2) = 1;
  
\end{Verbatim}
 The first two Wieferich primes can be found very quickly: \index{Filtered@\texttt{Filtered}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> Filtered([1..10000],IsWieferichPrimeInt);
  [ 1093, 3511 ]
  
\end{Verbatim}
 However, presently no third Wieferich prime is known. In case there is one, it
must be greater than $1.25 \cdot 10^{15}$ (cf.{\nobreakspace}\href{ http://www.loria.fr/~zimmerma/records/Wieferich.status} {McIntosh 2004}). 

 Assuming ``equidistribution'' of the residues $(2^{p-1}-1)/p$ mod{\nobreakspace}$p$, one might argue that the ``probability'' of a prime{\nobreakspace}$p$ to be a Wieferich prime should be about $1/p$. Since the series $\sum_{p \ \text{prime}} 1/p$ diverges, this would suggest that there are infinitely many Wieferich primes.
More concisely, one would expect that there are roughly $\ln(\ln(n))$ Wieferich primes less than a given bound{\nobreakspace}$n$. Following these speculations, the expected number of Wieferich primes below
the current bound of $1.25 \cdot 10^{15}$ would be $3.548$, while the actual number is{\nobreakspace}2. Obviously no reasonable
statistical conclusions can be made from that difference. 

 Well -- when trying random primes, it seems that you might perhaps have a
little chance of finding a new Wieferich prime! }

  
\section{\textcolor{Chapter }{Counting Words in a File (Solution)}}\label{sec:WordCountSolution}
\logpage{[ 2, 10, 0 ]}
\hyperdef{L}{X7E8385B57D503EB0}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:WordCountExercise}. 

 We can write the function as follows: \index{WordCount@\texttt{WordCount}} \index{Collected@\texttt{Collected}} \index{WordsString@\texttt{WordsString}} \index{StringFile@\texttt{StringFile}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  WordCount := filename -> Collected(WordsString(StringFile(filename)));
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Non-Metabelian p-Groups (Solution)}}\label{sec:NonMetabelianPGroupsSolution}
\logpage{[ 2, 11, 0 ]}
\hyperdef{L}{X868017AA79B0E23F}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:NonMetabelianPGroupsExercise}. 

 Let $p$ be a prime. It is well-known that groups of order $p$ or $p^2$ are always abelian, and that groups of prime-power order are solvable.
Therefore a non-metabelian $p$-group must at least have order $p^6$. Further it is easy to see that a group is metabelian if and only if its
derived subgroup is abelian. Thus we can proceed as follows: \index{First@\texttt{First}} \index{AllGroups@\texttt{AllGroups}} \index{IsAbelian@\texttt{IsAbelian}} \index{DerivedSubgroup@\texttt{DerivedSubgroup}} \index{IdGroup@\texttt{IdGroup}} \index{StructureDescription@\texttt{StructureDescription}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> G := First( AllGroups( 64), G -> not IsAbelian( DerivedSubgroup(G) ) );
  fail
  gap> G := First( AllGroups(128), G -> not IsAbelian( DerivedSubgroup(G) ) );
  <pc group of size 128 with 7 generators>
  gap> IdGroup(G);
  [ 128, 134 ]
  gap> StructureDescription(G);
  "((C4 : C8) : C2) : C2"
  gap> StructureDescription( DerivedSubgroup(G) );
  "C2 x D8"
  
\end{Verbatim}
 There is a complete classification of the positive integers{\nobreakspace}$n$ such that all groups of order{\nobreakspace}$n$ are metabelian. See{\nobreakspace}\cite{Pazderski80}. }

  
\section{\textcolor{Chapter }{The Growth of the Sum-of-Divisors Function (Solution)}}\label{sec:RHSolution}
\logpage{[ 2, 12, 0 ]}
\hyperdef{L}{X7A6B2AE87EC8B582}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:RHExercise}. 

 We can compute floating point approximations for $H(n)$ and $B(n)$ in \textsf{GAP} as follows: \index{Sum@\texttt{Sum}} \index{Float@\texttt{Float}} \index{LOG_FLOAT@\texttt{LOG{\textunderscore}FLOAT}} \index{EXP_FLOAT@\texttt{EXP{\textunderscore}FLOAT}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  H := n -> Sum([1..n],i->Float(1/i));
  B := n -> H(n) + LOG_FLOAT(H(n)) * EXP_FLOAT(H(n));
  
\end{Verbatim}
 We obtain for example \index{Sigma@\texttt{Sigma}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> List( [ 1 .. 60 ], n -> B(n) - Sigma(n) );
  [ 0, 0.317169, 1.62453, 0.977983, 4.38227, 0.834179, 7.32927, 2.86332, 
    7.43259, 5.03387, 13.6644, 0.321837, 17.0041, 9.70942, 12.4362, 8.1831, 
    23.9489, 5.73238, 27.5327, 8.34888, 21.1802, 20.0258, 34.8851, 1.7575, 
    33.6424, 25.5393, 30.4477, 17.3671, 46.2972, 7.2375, 50.1877, 22.1475, 
    40.1165, 37.0945, 46.0811, 6.0761, 62.0793, 43.0903, 50.1091, 19.1353, 
    70.1688, 19.2093, 74.2568, 37.311, 46.3717, 55.4389, 82.5122, 9.59174, 
    79.6772, 46.7685, 70.8655, 47.9681, 95.0762, 32.1896, 83.3082, 38.432, 
    81.5609, 74.6946, 107.833, 2.97668 ]
  
\end{Verbatim}
 However we cannot answer the question whether there is a positive
integer{\nobreakspace}$n$ such that $\sigma(n) > B(n)$ -- in fact, Jeffrey C. Lagarias{\nobreakspace}\cite{Lagarias02} has shown that this question is equivalent to the \href{ http://en.wikipedia.org/wiki/Riemann_Hypothesis} {Riemann hypothesis}! \index{Riemann hypothesis@Riemann hypothesis} }

  
\section{\textcolor{Chapter }{Pell's Equation (Solution)}}\label{sec:PellSolution}
\logpage{[ 2, 13, 0 ]}
\hyperdef{L}{X7BBA21EA7C0FEA03}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:PellExercise}. 

 We can write the function as follows: \index{FundamentalSolutionOfPellsEquation@\texttt{FundamentalSolutionOfPellsEquation}} \index{ContinuedFractionExpansionOfRoot@\texttt{ContinuedFractionExpansionOfRoot}} \index{ContinuedFractionApproximationOfRoot@\texttt{ContinuedFractionApproximationOfRoot}} \index{RootInt@\texttt{RootInt}} \index{Indeterminate@\texttt{Indeterminate}} \index{Length@\texttt{Length}} \index{NumeratorRat@\texttt{NumeratorRat}} \index{DenominatorRat@\texttt{DenominatorRat}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  FundamentalSolutionOfPellsEquation := function ( n )
  
    local  x, periodlength, approx;
  
    if n = RootInt(n,2)^2 then return fail; fi;
    x := Indeterminate(Integers);
    periodlength := Length(ContinuedFractionExpansionOfRoot(x^2-n,0)) - 1;
    if   periodlength mod 2 = 0
    then approx := ContinuedFractionApproximationOfRoot(x^2-n,  periodlength);
    else approx := ContinuedFractionApproximationOfRoot(x^2-n,2*periodlength);
    fi;
    return [ NumeratorRat(approx), DenominatorRat(approx) ];
  end;
  
\end{Verbatim}
 First we determine the length of the period of the continued fraction
expansion of the square root of{\nobreakspace}\mbox{\texttt{\mdseries\slshape n}}. Then we determine the fundamental solution of Pell's equation by taking the
numerator and the denominator of a suitable continued fraction approximation
of that square root (note the dependency on the parity of the period length!).
Examples are 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> FundamentalSolutionOfPellsEquation(2);
  [ 3, 2 ]
  gap> FundamentalSolutionOfPellsEquation(5);
  [ 9, 4 ]
  gap> FundamentalSolutionOfPellsEquation(13);
  [ 649, 180 ]
  gap> FundamentalSolutionOfPellsEquation(15);
  [ 4, 1 ]
  gap> FundamentalSolutionOfPellsEquation(61);
  [ 1766319049, 226153980 ]
  
\end{Verbatim}
 ... and for $n = 421$ we obtain 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> FundamentalSolutionOfPellsEquation(421);
  [ 3879474045914926879468217167061449, 189073995951839020880499780706260 ]
  
\end{Verbatim}
 }

  
\section{\textcolor{Chapter }{Automorphism Groups of Odd Order (Solution)}}\label{sec:AutomorphismGroupOfOddOrderSolution}
\logpage{[ 2, 14, 0 ]}
\hyperdef{L}{X81ACCC777887640E}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:AutomorphismGroupOfOddOrderExercise}. 

 It suffices to look at groups of odd order: Assume that $G$ is a group of even order, and let $G_2$ be its Sylow 2-subgroup. If $G_2$ is not a subgroup of the centre of{\nobreakspace}$G$, then already the inner automorphism group has even order. If it is a
subgroup of the centre of{\nobreakspace}$G$, then we have $G = G_2 \times G_{2'}$, and therefore Aut($G$) = Aut($G_2$) $\times$ Aut($G_{2'}$). In this case, already the automorphism group of $G_{2'}$ has odd order, and $G$ is not the smallest group having this property. 

 We perform a \emph{brute-force} search: \index{Print@\texttt{Print}} \index{First@\texttt{First}} \index{AllGroups@\texttt{AllGroups}} \index{Size@\texttt{Size}} \index{AutomorphismGroup@\texttt{AutomorphismGroup}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> n := 3;;
  gap> repeat
  >      Print(n,"\n");
  >      G := First(AllGroups(n),G->Size(AutomorphismGroup(G)) mod 2 = 1);
  >      n := n + 2;
  >    until G <> fail;
  
\end{Verbatim}
 This loop runs for quite a while. We obtain the following: \index{IdGroup@\texttt{IdGroup}} \index{StructureDescription@\texttt{StructureDescription}} \index{DerivedSubgroup@\texttt{DerivedSubgroup}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> G;
  <pc group of size 729 with 6 generators>
  gap> IdGroup(G);
  [ 729, 31 ]
  gap> AutomorphismGroup(G);
  <group of size 19683 with 9 generators>
  gap> StructureDescription(DerivedSubgroup(G));
  "C9"
  gap> StructureDescription(G/DerivedSubgroup(G));
  "C9 x C9"
  
\end{Verbatim}
 The result that $3^6$ is the smallest order of a group of more than 2 elements with an odd order
automorphism group has first been obtained in{\nobreakspace}\cite{MacHaleSheehy95}. }

  
\section{\textcolor{Chapter }{Composite Sums (Solution)}}\label{sec:CompositeSumsSolution}
\logpage{[ 2, 15, 0 ]}
\hyperdef{L}{X7F3E7A848496D8DD}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:CompositeSumsExercise}. 

 First we look for odd integers $n$ such that any sum $n+2^k$ for ``small'' $k$ has a ``small'' prime divisor: \index{Product@\texttt{Product}} \index{Primes@\texttt{Primes}} \index{Filtered@\texttt{Filtered}} \index{First@\texttt{First}} \index{Gcd@\texttt{Gcd}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> m := Product(Primes);;
  gap> Filtered([1,3..99999],n->First([0..500],k->Gcd(n+2^k,m)=1)=fail);
  [ 78557 ]
  
\end{Verbatim}
 Now our goal is to find out whether in fact \emph{all} sums $78557+2^k$ are composite. 

 \index{ResClasses package@ResClasses package} For this, we first determine the smallest prime factors of the numbers $78557+2^k$ for ``small'' values of{\nobreakspace}$k$. Then we find out for which $k$ these primes $p_i$ divide $78557+2^k$. The set of such $k$ is the set of positive integers in a residue class modulo the order of
2{\nobreakspace}(mod{\nobreakspace}$p_i$). Finally we form the union of the residue classes we obtain, and check
whether it equals{\nobreakspace}$\mathbb{Z}$ (this needs the \textsf{ResClasses} package{\nobreakspace}\cite{ResClasses}): \index{Set@\texttt{Set}} \index{Minimum@\texttt{Minimum}} \index{Factors@\texttt{Factors}} \index{List@\texttt{List}} \index{OrderMod@\texttt{OrderMod}} \index{Length@\texttt{Length}} \index{TransposedMat@\texttt{TransposedMat}} \index{ResidueClass@\texttt{ResidueClass}} \index{Union@\texttt{Union}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> primes := Set([1..100],k->Minimum(Factors(Gcd(78557+2^k,m))));
  [ 3, 5, 7, 13, 19, 37, 73 ]
  gap> m_i := List(primes,p->OrderMod(2,p));
  [ 2, 4, 3, 12, 18, 36, 9 ]
  gap> r_i := List([1..Length(primes)],
  >                i->First([0..m_i[i]-1],k->(78557+2^k) mod primes[i] = 0));
  [ 0, 3, 2, 1, 3, 9, 6 ]
  gap> residueclasses := List(TransposedMat([r_i,m_i]),ResidueClass);
  [ 0(2), 3(4), 2(3), 1(12), 3(18), 9(36), 6(9) ]
  gap> Union(residueclasses);
  Integers
  
\end{Verbatim}
 Now we know that all sums $78557+2^k$ for positive integers $k$ are composite. But is 78557 indeed the smallest odd integer such that $n+2^k$ is composite for all positive integers{\nobreakspace}$k$? -- Likely yes, but answering this question is computationally difficult: \index{IsProbablyPrimeInt@\texttt{IsProbablyPrimeInt}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> k_s := List([1,3..78557],
  >                n->First([1..1000],k->IsProbablyPrimeInt(n+2^k)));;
  gap> k_s{[1..100]}; # small n are not a problem ...
  [ 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 3, 2, 1, 1, 4, 2, 1, 2, 1, 1, 2, 1, 5, 2, 
    1, 3, 2, 1, 1, 8, 2, 1, 2, 1, 1, 4, 2, 1, 2, 1, 7, 2, 1, 3, 4, 2, 1, 2, 1, 
    1, 2, 1, 1, 2, 1, 7, 4, 5, 3, 4, 2, 1, 2, 1, 3, 2, 1, 1, 10, 3, 3, 2, 1, 1, 
    4, 2, 1, 4, 2, 1, 2, 1, 5, 2, 1, 3, 2, 1, 1, 4, 3, 3, 2, 1, 1, 2, 1, 1, 6 ]
  gap> 2*Positions(k_s,fail)-1; # ... but larger n are:
  [ 2131, 2491, 4471, 5101, 6379, 6887, 7013, 8447, 8543, 9833, 10711, 14033, 
    14551, 14573, 14717, 15623, 16519, 17659, 18527, 19081, 19249, 20209, 
    20273, 21143, 21661, 22193, 23147, 23221, 23971, 24953, 26213, 26491, 
    28433, 29333, 29777, 30197, 31111, 31369, 31951, 32449, 32513, 34429, 
    35461, 36083, 36721, 37217, 37967, 38387, 39079, 40291, 40351, 40613, 
    41453, 41693, 43579, 47269, 48091, 48331, 48527, 48859, 48961, 49279, 
    49577, 50839, 52339, 53119, 53359, 56717, 57083, 59071, 60443, 60451, 
    60947, 60961, 62029, 63691, 64133, 64643, 65033, 65089, 65719, 67607, 
    69593, 69709, 70321, 72679, 73373, 73583, 75353, 75841, 77041, 77783, 
    77899, 78557 ]
  
\end{Verbatim}
 Using a bound larger than 1000 for $k$, it is possible to eliminate many of the above values of{\nobreakspace}$n$, but eliminating all of them except of 78557 seems hard. 

 See also the related term \href{http://en.wikipedia.org/wiki/Sierpinski_number } {Sierpinski number}, and the corresponding distributed computing project \href{ http://www.rechenkraft.net/wiki/index.php?title=Seventeen_or_bust} {Seventeen or bust}. 

 The interested reader might have a look at the similar problem with Fibonacci
numbers instead of powers of{\nobreakspace}2. }

  
\section{\textcolor{Chapter }{Rational Points on the Unit Sphere (Solution) }}\label{sec:RationalPointsSolution}
\logpage{[ 2, 16, 0 ]}
\hyperdef{L}{X86BFAFD781969442}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:RationalPointsExercise}. 

 The function can be written as follows: \index{RationalPointsOnUnitSphere@\texttt{RationalPointsOnUnitSphere}} \index{Zero@\texttt{Zero}} \index{One@\texttt{One}} \index{GF@\texttt{GF}} \index{NullMat@\texttt{NullMat}} \index{RootInt@\texttt{RootInt}} \index{List@\texttt{List}} \index{Arrangements@\texttt{Arrangements}} \index{SaveAsBitmapPicture@\texttt{SaveAsBitmapPicture}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  RationalPointsOnUnitSphere := function ( max_abc, size, filename )
  
    local  picture, solutions, a, b, c, d, sum,
           pixelcoords, mirror, zero, one, i, j;
  
    zero := Zero(GF(2)); one := One(GF(2)); # create a white picture:
    picture := NullMat(size,size,GF(2));
    for i in [1..size] do for j in [1..size] do picture[i][j] := one; od; od;
  
    solutions := 0;
    for a in [1..max_abc] do
      Print("a = ",a,", #solutions = ",solutions,"\n");
      for b in [1..a] do
        for c in [1..b] do
          sum := a^2 + b^2 + c^2;
          d   := RootInt(sum);
          if d^2 = sum then
            pixelcoords := List( size * [a,b,c]/d, Int ) + 1;
            for mirror in Arrangements([1..3],2) do
              picture[pixelcoords[mirror[1]]][pixelcoords[mirror[2]]] := zero;
            od;
            solutions := solutions + 1;
          fi;
        od;
      od;
    od;
    SaveAsBitmapPicture(picture,filename);
  end;
  
\end{Verbatim}
 With some patience, you can use this function to produce a picture like \href{ http://www.cip.mathematik.uni-stuttgart.de/~kohlsn/images/sphere1.gif} {this}. }

  
\section{\textcolor{Chapter }{Aliquot Sequences (Solution) }}\label{sec:AliquotSolution}
\logpage{[ 2, 17, 0 ]}
\hyperdef{L}{X8719302881C72AB2}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:AliquotExercise}. 

 \index{AliquotSequence@\texttt{AliquotSequence}} \index{Sigma@\texttt{Sigma}} \index{@\texttt{}} We can write the following \textsf{GAP} function: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  AliquotSequence := function ( n )
  
    local  a, i;
  
    a := [n]; i := 1;
    while a[i] > 1 and not a[i] in a{[1..i-1]} do
      a[i+1] := Sigma(a[i]) - a[i]; i := i + 1;
    od;
    return a;
  end;
  
\end{Verbatim}
 This yields the following: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> List([1..40],AliquotSequence);
  [ [ 1 ], [ 2, 1 ], [ 3, 1 ], [ 4, 3, 1 ], [ 5, 1 ], [ 6, 6 ], [ 7, 1 ], 
    [ 8, 7, 1 ], [ 9, 4, 3, 1 ], [ 10, 8, 7, 1 ], [ 11, 1 ], 
    [ 12, 16, 15, 9, 4, 3, 1 ], [ 13, 1 ], [ 14, 10, 8, 7, 1 ], 
    [ 15, 9, 4, 3, 1 ], [ 16, 15, 9, 4, 3, 1 ], [ 17, 1 ], [ 18, 21, 11, 1 ], 
    [ 19, 1 ], [ 20, 22, 14, 10, 8, 7, 1 ], [ 21, 11, 1 ], 
    [ 22, 14, 10, 8, 7, 1 ], [ 23, 1 ], [ 24, 36, 55, 17, 1 ], [ 25, 6, 6 ], 
    [ 26, 16, 15, 9, 4, 3, 1 ], [ 27, 13, 1 ], [ 28, 28 ], [ 29, 1 ], 
    [ 30, 42, 54, 66, 78, 90, 144, 259, 45, 33, 15, 9, 4, 3, 1 ], [ 31, 1 ], 
    [ 32, 31, 1 ], [ 33, 15, 9, 4, 3, 1 ], [ 34, 20, 22, 14, 10, 8, 7, 1 ], 
    [ 35, 13, 1 ], [ 36, 55, 17, 1 ], [ 37, 1 ], [ 38, 22, 14, 10, 8, 7, 1 ], 
    [ 39, 17, 1 ], [ 40, 50, 43, 1 ] ]
  gap> List([1..275],n->Length(AliquotSequence(n)));
  [ 1, 2, 2, 3, 2, 2, 2, 3, 4, 4, 2, 7, 2, 5, 5, 6, 2, 4, 2, 7, 3, 6, 2, 5, 3, 
    7, 3, 2, 2, 15, 2, 3, 6, 8, 3, 4, 2, 7, 3, 4, 2, 14, 2, 5, 7, 8, 2, 6, 4, 
    3, 4, 9, 2, 13, 3, 5, 3, 4, 2, 11, 2, 9, 3, 4, 3, 12, 2, 5, 4, 6, 2, 9, 2, 
    5, 5, 5, 3, 11, 2, 7, 5, 6, 2, 6, 3, 9, 7, 7, 2, 10, 4, 6, 4, 4, 4, 9, 2, 
    3, 4, 5, 2, 18, 2, 7, 8, 6, 2, 10, 2, 7, 3, 9, 2, 17, 3, 5, 4, 10, 4, 12, 
    8, 5, 8, 6, 3, 16, 2, 3, 3, 6, 2, 11, 4, 7, 9, 8, 2, 178, 2, 5, 5, 6, 4, 9, 
    4, 6, 6, 11, 2, 177, 2, 12, 6, 8, 3, 8, 2, 7, 4, 11, 3, 4, 2, 7, 9, 10, 2, 
    175, 6, 9, 3, 9, 2, 16, 3, 5, 4, 7, 2, 52, 2, 9, 4, 6, 3, 15, 3, 12, 3, 10, 
    2, 13, 2, 6, 6, 4, 2, 14, 2, 4, 3, 8, 3, 10, 3, 7, 9, 7, 3, 52, 2, 11, 6, 
    8, 5, 10, 4, 10, 4, 3, 3, 176, 2, 17, 8, 6, 2, 8, 2, 9, 7, 11, 2, 175, 3, 
    7, 3, 7, 2, 11, 2, 3, 9, 11, 3, 15, 7, 12, 8, 11, 2, 17, 4, 7, 5, 6, 2, 14, 
    8, 11, 4, 8, 2, 31, 3, 9, 5, 8, 2, 13, 2, 12, 4, 6, 3 ]
  gap> Maximum(last);
  178
  gap> Position(last2,last);
  138
  gap> AliquotSequence(138);
  [ 138, 150, 222, 234, 312, 528, 960, 2088, 3762, 5598, 6570, 10746, 13254, 
    13830, 19434, 20886, 21606, 25098, 26742, 26754, 40446, 63234, 77406, 
    110754, 171486, 253458, 295740, 647748, 1077612, 1467588, 1956812, 2109796, 
    1889486, 953914, 668966, 353578, 176792, 254128, 308832, 502104, 753216, 
    1240176, 2422288, 2697920, 3727264, 3655076, 2760844, 2100740, 2310856, 
    2455544, 3212776, 3751064, 3282196, 2723020, 3035684, 2299240, 2988440, 
    5297320, 8325080, 11222920, 15359480, 19199440, 28875608, 25266172, 
    19406148, 26552604, 40541052, 54202884, 72270540, 147793668, 228408732, 
    348957876, 508132204, 404465636, 303708376, 290504024, 312058216, 
    294959384, 290622016, 286081174, 151737434, 75868720, 108199856, 101437396, 
    76247552, 76099654, 42387146, 21679318, 12752594, 7278382, 3660794, 
    1855066, 927536, 932464, 1013592, 1546008, 2425752, 5084088, 8436192, 
    13709064, 20563656, 33082104, 57142536, 99483384, 245978376, 487384824, 
    745600776, 1118401224, 1677601896, 2538372504, 4119772776, 8030724504, 
    14097017496, 21148436904, 40381357656, 60572036544, 100039354704, 
    179931895322, 94685963278, 51399021218, 28358080762, 18046051430, 
    17396081338, 8698040672, 8426226964, 6319670230, 5422685354, 3217383766, 
    1739126474, 996366646, 636221402, 318217798, 195756362, 101900794, 
    54202694, 49799866, 24930374, 17971642, 11130830, 8904682, 4913018, 
    3126502, 1574810, 1473382, 736694, 541162, 312470, 249994, 127286, 69898, 
    34952, 34708, 26038, 13994, 7000, 11720, 14740, 19532, 16588, 18692, 14026, 
    7016, 6154, 3674, 2374, 1190, 1402, 704, 820, 944, 916, 694, 350, 394, 200, 
    265, 59, 1 ]
  
\end{Verbatim}
 \index{FactInt package@FactInt package} \index{method installation@method installation} Thus we see that indeed all Aliquot sequences starting at integers $n \leq 275$ either stop or run into cycles. So far, everything runs quickly and there are
no performance problems of any kind. However, $n = 276$ causes severe problems -- the sequence grows, and factoring becomes a serious
problem. As suggested in the hints, we install the following modified \textsf{GAP} Library method for the operation \texttt{Sigma} to ensure that \textsf{FactInt}{\nobreakspace}\cite{FactInt} is used for factoring integers: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  InstallMethod( Sigma, "use FactInt", true, [ IsPosInt ], SUM_FLAGS,
  
    function( n )
  
      local  sigma, p, q, k;
  
      # make <n> it nonnegative, handle trivial cases
      if n < 0 then n := -n; fi;
      if n = 0 then Error("Sigma: <n> must not be 0"); fi;
      if n <= Length(DivisorsIntCache) then
        return Sum(DivisorsIntCache[n]);
      fi;
  
      # loop over all prime factors p of n
      sigma := 1;
      for p in Set(Factors(n)) do
  
        # compute p^e and k = 1+p+p^2+..p^e
        q := p;  k := 1 + p;
        while n mod (q * p) = 0 do q := q * p; k := k + q; od;
     
        # combine with the value found so far
        sigma := sigma * k;
  
      od;
  
      return sigma;
    end );
  
\end{Verbatim}
 \index{Print@\texttt{Print}} \index{FactIntInfo@\texttt{FactIntInfo}} \index{Info messages@Info messages} Further we insert a \texttt{Print} statement into our \texttt{AliquotSequence} function, and we switch on \textsf{FactInt}'s \texttt{Info}'s whenever large integers are to be factored: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  AliquotSequence := function ( n )
  
    local  a, i;
  
    a := [n]; i := 1;
    while a[i] > 1 and not a[i] in a{[1..i-1]} do
      if a[i] > 10^40 then FactIntInfo(3); fi;
      Factors(a[i]);
      FactIntInfo(0);
      Print(String(i,6)," : ",a[i]," = ");
      PrintFactorsInt(a[i]); Print("\n");
      a[i+1] := Sigma(a[i]) - a[i];
      i := i + 1;
    od;
    return a;
  end;
  
\end{Verbatim}
 Now try out yourself how far you can get with computing the \href{ http://en.wikipedia.org/wiki/Aliquot_sequence} {Aliquot sequence} starting at 276{\nobreakspace}...{\nobreakspace}! }

  
\section{\textcolor{Chapter }{The Q Sequence (Solution) }}\label{sec:QSolution}
\logpage{[ 2, 18, 0 ]}
\hyperdef{L}{X7F9840A8797DA032}{}
{
  This is a suggested solution for Exercise{\nobreakspace}\ref{sec:QExercise}. 

 \index{Q@\texttt{Q}} \index{QSequence@\texttt{QSequence}} \index{iterative vs. recursive@iterative vs. recursive} \index{recursive vs. iterative@recursive vs. iterative} 
\begin{description}
\item[{ad a)}]  We can write either the following recursive 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  Q := function ( n )
    if   n in [1,2]
    then return 1;
    else return Q(n-Q(n-1)) + Q(n-Q(n-2)); fi;
  end;
  QSequence := l -> List([1..l],Q);
  
\end{Verbatim}
 or the following iterative code; 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  QSequence := function ( l )
  
    local  Q, n;
  
    Q := [1,1];
    for n in [3..l] do
      Q[n] := Q[n-Q[n-1]] + Q[n-Q[n-2]];
    od;
    return Q;
  end;
  
\end{Verbatim}
 With the recursive approach, we get something like the following timings: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> QSequence(10);
  [ 1, 1, 2, 3, 3, 4, 5, 5, 6, 6 ]
  gap> time;
  0
  gap> QSequence(20);
  [ 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12 ]
  gap> time;
  220
  gap> QSequence(30);
  [ 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12, 12, 12, 
    12, 16, 14, 14, 16, 16, 16, 16 ]
  gap> time;
  26640
  
\end{Verbatim}
 Thus we observe a horrible increase in runtime. With the iterative approach,
this looks quite different: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> QSequence(200);
  [ 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 6, 8, 8, 8, 10, 9, 10, 11, 11, 12, 12, 12, 
    12, 16, 14, 14, 16, 16, 16, 16, 20, 17, 17, 20, 21, 19, 20, 22, 21, 22, 23, 
    23, 24, 24, 24, 24, 24, 32, 24, 25, 30, 28, 26, 30, 30, 28, 32, 30, 32, 32, 
    32, 32, 40, 33, 31, 38, 35, 33, 39, 40, 37, 38, 40, 39, 40, 39, 42, 40, 41, 
    43, 44, 43, 43, 46, 44, 45, 47, 47, 46, 48, 48, 48, 48, 48, 48, 64, 41, 52, 
    54, 56, 48, 54, 54, 50, 60, 52, 54, 58, 60, 53, 60, 60, 52, 62, 66, 55, 62, 
    68, 62, 58, 72, 58, 61, 78, 57, 71, 68, 64, 63, 73, 63, 71, 72, 72, 80, 61, 
    71, 77, 65, 80, 71, 69, 77, 75, 73, 77, 79, 76, 80, 79, 75, 82, 77, 80, 80, 
    78, 83, 83, 78, 85, 82, 85, 84, 84, 88, 83, 87, 88, 87, 86, 90, 88, 87, 92, 
    90, 91, 92, 92, 94, 92, 93, 94, 94, 96, 94, 96, 96, 96, 96, 96, 96, 128, 
    72, 96, 115, 100, 84, 114, 110, 93 ]
  gap> time;
  0
  
\end{Verbatim}
 Let's have a look how often \texttt{Q} calls itself in the recursive version: \index{QCallCounts@\texttt{QCallCounts}} \index{ListWithIdenticalEntries@\texttt{ListWithIdenticalEntries}} 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  QCallCounts := function ( n )
  
    local  Q, sequence;
  
    Q := function ( n )
      sequence[n] := sequence[n] + 1;
      if   n in [1,2]
      then return 1;
      else return Q(n-Q(n-1)) + Q(n-Q(n-2)); fi;
    end;
  
    sequence := ListWithIdenticalEntries(n,0);
    Q(n);
    return sequence;
  end;
  
\end{Verbatim}
 We obtain 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP session log]
  
  gap> QCallCounts(30);
  [ 1477421, 5444369, 1477421, 415342, 181422, 98727, 55073, 31366, 18752, 
    11250, 6884, 4238, 2604, 1601, 987, 610, 377, 233, 144, 89, 55, 34, 21, 13, 
    8, 5, 3, 2, 1, 1 ]
  
\end{Verbatim}
 This clearly explains the poor performance. (By the way: The end of the
sequence seems to be the reversed beginning of the sequence of Fibonacci
numbers -- can you find out something about this?) 
\item[{ad b)}]  \index{PlotQSequence@\texttt{PlotQSequence}} \index{Maximum@\texttt{Maximum}} \index{NullMat@\texttt{NullMat}} \index{Zero@\texttt{Zero}} \index{One@\texttt{One}} \index{GF@\texttt{GF}} \index{SaveAsBitmapPicture@\texttt{SaveAsBitmapPicture}} We can write the following \textsf{GAP} function: 
\begin{Verbatim}[fontsize=\small,frame=single,label=GAP code]
  
  PlotQSequence := function ( l, filename )
  
    local  Q, graph, h, n, i, j, zero, one;
  
    Q := QSequence(l);
    h := Maximum(Q); # use the maximum as the height of the picture
    graph := NullMat(h,l);
    zero := Zero(GF(2)); one := One(GF(2));
    for i in [1..h] do for j in [1..l] do graph[i][j] := one; od; od;
    for n in [1..l] do graph[Q[n]][n] := zero; od;
    SaveAsBitmapPicture(graph,filename);
  end;
  
\end{Verbatim}
 
\end{description}
 }

  }

  \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{exercises-bib.xml}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
